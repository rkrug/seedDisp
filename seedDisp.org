# -*- org-babel-tangled-file: t; org-babel-tangle-run-postTangleScript: t; -*-

#+TITLE:     seedDisp.org
#+AUTHOR:    Rainer M Krug
#+EMAIL:     Rainer@krugs.de
#+DESCRIPTION: R Package Development Helpers
#+KEYWORDS: 

:CONFIG:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 

#+TODO: TODO OPTIMIZE TOGET COMPLETE WAIT VERIFY CHECK CODE DOCUMENTATION | DONE RECEIVED CANCELD 

#+STARTUP: indent hidestars nohideblocks
#+DRAWERS: HIDDEN PROPERTIES STATE CONFIG BABEL OUTPUT LATEXHEADER HTMLHEADER
#+STARTUP: nohidestars hideblocks
:END:
:HTMLHEADER:
#+begin_html
  <div id="subtitle" style="float: center; text-align: center;">
  <p>
Org-babel support for building 
  <a href="http://www.r-project.org/">R</a> packages
  </p>
  <p>
  <a href="http://www.r-project.org/">
  <img src="http://www.r-project.org/Rlogo.jpg"/>
  </a>
  </p>
  </div>
#+end_html
:END:
:LATEXHEADER:
#+LATEX_HEADER: \usepackage{rotfloat}
#+LATEX_HEADER: \definecolor{light-gray}{gray}{0.9}
#+LATEX_HEADER: \lstset{%
#+LATEX_HEADER:     basicstyle=\ttfamily\footnotesize,       % the font that is used for the code
#+LATEX_HEADER:     tabsize=4,                       % sets default tabsize to 4 spaces
#+LATEX_HEADER:     numbers=left,                    % where to put the line numbers
#+LATEX_HEADER:     numberstyle=\tiny,               % line number font size
#+LATEX_HEADER:     stepnumber=0,                    % step between two line numbers
#+LATEX_HEADER:     breaklines=true,                 %!! don't break long lines of code
#+LATEX_HEADER:     showtabs=false,                  % show tabs within strings adding particular underscores
#+LATEX_HEADER:     showspaces=false,                % show spaces adding particular underscores
#+LATEX_HEADER:     showstringspaces=false,          % underline spaces within strings
#+LATEX_HEADER:     keywordstyle=\color{blue},
#+LATEX_HEADER:     identifierstyle=\color{black},
#+LATEX_HEADER:     stringstyle=\color{green},
#+LATEX_HEADER:     commentstyle=\color{red},
#+LATEX_HEADER:     backgroundcolor=\color{light-gray},   % sets the background color
#+LATEX_HEADER:     columns=fullflexible,  
#+LATEX_HEADER:     basewidth={0.5em,0.4em}, 
#+LATEX_HEADER:     captionpos=b,                    % sets the caption position to `bottom'
#+LATEX_HEADER:     extendedchars=false              %!?? workaround for when the listed file is in UTF-8
#+LATEX_HEADER: }
:END:
:BABEL:
#+PROPERTY: exports code
#+PROPERTY: comments yes
#+PROPERTY: padline no
#+PROPERTY: var MAJORVERSION=0
#+PROPERTY: var+ MINORVERSION=5
#+PROPERTY: var+ PATCHVERSION=1
#+PROPERTY: var+ GITHASH="testhash" 
#+PROPERTY: var+ GITCOMMITDATE="testdate"
:END:

* Internal configurations                      :noexport:
** Evaluate to run post tangle script
#+begin_src emacs-lisp :results silent :tangle no :exports none
(add-hook 'org-babel-post-tangle-hook
          (
           lambda () 
                  (call-process-shell-command "./postTangleScript.sh" nil 0 nil)
  ;;              (async-shell-command "./postTangleScript.sh")
  ;;              (ess-load-file (save-window-excursion (replace-regexp-in-string ".org" ".R" buffer-file-name)))))
  ;;              (ess-load-file "nsa.R")))
  ;;              (ess-load-file "spreadSim.R")
                  ))
#+end_src

** Post tangle script
:PROPERTIES:
:tangle: postTangleScript.sh
:END:
#+begin_src sh :tangle postTangleScript.sh
  sed -i '' s/MAJORVERSION/$MAJORVERSION/ ./DESCRIPTION
  sed -i '' s/MINORVERSION/$MINORVERSION/ ./DESCRIPTION
  sed -i '' s/PATCHVERSION/$PATCHVERSION/ ./DESCRIPTION
  sed -i '' s/TODAYSDATE/`date +%Y-%m-%d_%H-%M`/ ./DESCRIPTION

  sed -i '' s/MAJORVERSION/$MAJORVERSION/ ./R/package.R
  sed -i '' s/MINORVERSION/$MINORVERSION/ ./R/package.R
  sed -i '' s/PATCHVERSION/$PATCHVERSION/ ./R/package.R
  sed -i '' s/TODAYSDATE/`date +%Y-%m-%d_%H-%M`/ ./R/package.R

  Rscript -e "library(roxygen2);roxygenize('.')"
  # rm -f ./postTangleScript.sh
#+end_src

#+RESULTS:
| Updating | roxygen             | version | in | /Users/rainerkrug/Documents/Projects/R-Packages/AlienSpread/seedDisp/DESCRIPTION |
| Writing  | seedDisp-package.Rd |         |    |                                                                                  |


* gitignore file (./.gitignore)
:PROPERTIES:
:tangle: ./.gitignore
:comments: no
:no-expand: TRUE
:shebang:
:padline: no
:END: 
#+begin_src gitignore
.#*
#*
,*#
,*~
,*#seedDisp.*
seedDisp.*
!seedDisp.org*
,*.o
,*.so
,*.rds
/postTangleScript.sh
#+end_src

* Git Revision info
Complete version info
#+begin_src sh :exports results :results output replace 
  echo "Version     : " $MAJORVERSION.$MINORVERSION-$PATCHVERSION
  echo "Commit date : " `git show -s --format="%ci" HEAD`
  echo "git HASH    : " `git rev-parse HEAD`
  echo "git status  : "
  git status
#+end_src

#+RESULTS:
: Version     :  0.4-13
: Commit date :  2013-09-09 15:49:55 +0200
: git HASH    :  1a70e43c2c6385e74ac6a0f577b6ae77dffd05bf
: git status  : 
: # On branch master
: nothing to commit (working directory clean)



* Rbuildignore file (./.Rbuildignore)
:PROPERTIES:
:tangle: ./.Rbuildignore
:comments: no
:no-expand: TRUE
:shebang:
:padline: no
:END: 
#+begin_src fundamental
.git
^.*\\.org$
^seedDisp.
.gitignore
library
version
postTangleScript.sh
#+end_src



* Package Files
** DESCRIPTION
:PROPERTIES:
:tangle:   ./DESCRIPTION
:padline: no 
:no-expand: TRUE
:comments: no
:END:
#+begin_src fundamental
Package: seedDisp
Type: Package
Title: Dispersal of seed routines
Version: MAJORVERSION.MINORVERSION-PATCHVERSION
Date: TODAYSDATE
Author: Rainer M. Krug <Rainer@krugs.de>
Maintainer: Rainer M. Krug <Rainer@krugs.de>
Description: Collection of different seed dispersal routines.
License: GPL-3
LazyLoad: yes
Imports: Rcpp (>= 0.9.4), sp, rgrass7
LinkingTo: Rcpp  
#+end_src

** NAMESPACE
:PROPERTIES:
:tangle:   ./NAMESPACE
:padline: no 
:no-expand: TRUE
:comments: no
:END:
#+begin_src R
  useDynLib(seedDisp)
  exportPattern("^[[:alpha:]]+")
#+end_src

#+results:

** Package description (./R/package.R)
:PROPERTIES:
:tangle:   ./R/package.R
:eval: nil
:no-expand: TRUE
:comments: no
:END:
#+begin_src R 
##' Disperses seeds by using different routines
##'
##' This package is a collection of different seed sispersal routines. 
##'
##' 
##' \tabular{ll}{
##' Package: \tab seedDisp\cr
##' Type: \tab Package\cr
##' Version: \tab MAJORVERSION.MINORVERSION-PATCHVERSION\cr
##' Date: \tab TODAYSDATE\cr
##' License: \tab GPL (>= 2)\cr
##' LazyLoad: \tab yes\cr
##' }
##'
##' @name seedDisp-package
##' @docType package
##' @author Rainer M Krug \email{Rainer@@krugs.de}
##' @import Rcpp
##' @import sp
##' @import rgrass7
NULL
#+end_src


* R directory (./R)
** Wind dispersal
*** windDisp
#+begin_src R :eval nil :tangle ./R/windDisp.R :no-expand
##' Disperses seeds from a matrix by using a 2 dimensional dispersal kernel
##'
##' This function uses a 2D seed dispersal kernel in form of a \code{matrix} to disperse seeds
##' from a seed source in form of a \code{matrix} and returns a \code{matrix} of the same size
##' containing the seed distribnution after the seeds in the original seed matrix are dispersed.
##' 
##' The function uses an inverse approach, by going over all cells and determining the number of
##' seeds dispersed \bold{into} the cell from all the cells under the dispersel kernel.
##' To calculate the number of seeds dispersed into each cell, the foolowing steps are done:
##' 
##' 1) The dispersal kernel is centered over the for which the number of seeds to be dispersed into
##' will be calculated
##' 
##' 2) for each cell under the dispersal kernel \code{SD2D} the following is done
##' 
##' 2.1) if the corresponding cell in MASK is \code{NA}, no seeds are dispersed into this cell
##' 
##' 2.2) for each cell under the kernel \code{SD2D} for which the underlying MASK is not NA a binominal distributed random number is drawn with
##' 
##'         \code{rbinom(1, noOfSeeds, prob)} \cr
##'         \code{noOfSeeds} : number of seeds in the cell from which the seeds orriginate \cr
##'         \code{prob} : probability from \code{SD2D} kernel of the corresponding cell
##' 
##'      and summed up for the whole kernel.
##' 
##' This function is implemented in C (\code{windDispCpp})
##'
##' The C function requires the seed raster to be buffered by half
##' the width of the seed dispertsal kernel \code{SD2D} which is done
##' in the function before calling the C function.
##' 
##' 
##' @usage windDisp(SD2D, SEEDS, MASK, zeroToNULL)
##' @name windDisp
##' @title Dispersal of seeds by wind
##' 
##' @param SD2D Sedd Dispersal kernel 2D - \code{matrix} defining the 2D seed dispersal kernel 
##' @param SEEDS \code{matrix} specifying the number of seeds to be dispersed
##' @param MASK \code{matrix} defining the area in which processing takes place (\code{!is.na(MASK)}) 
##' @param zeroToNULL \code{boolean} if TRUE replace 0 with NA in the returned \code{matrix}, 
##' otherwise all NA will be replaced with 0
##' 
##' @return \code{matrix} of same size as \code{SEEDS} containing the dispersed seeds
##' @author Rainer M Krug \email{Rainer@@krugs.de}
##' 
##' @useDynLib seedDisp
##' @export 

windDisp <- function(SD2D, SEEDS, MASK, zeroToNULL) {
    ## Calculate size parameter of sd2D
    dx2 <- (ncol(SD2D) - 1)
    dy2 <- (nrow(SD2D) - 1)
    dx <- dx2 / 2
    dy <- dy2 / 2
    ## buffer MASK and SEEDS for dispersal into cells at the edge
    buffer <- matrix(NA, nrow=nrow(SEEDS), ncol=dx)
    SEEDS <- cbind(buffer, SEEDS, buffer)
    MASK <- cbind(buffer, MASK, buffer)
    buffer <- matrix(NA, ncol=ncol(SEEDS), nrow=dy)
    SEEDS <- rbind(buffer, SEEDS, buffer)
    MASK <- rbind(buffer, MASK, buffer)
    ## call C++ function
    output <- .Call(
        "windDispCpp",
        dx2,
        dy2,
        SD2D,
        SEEDS,
        MASK,
        PACKAGE = "seedDisp"
        )
    if (zeroToNULL) {
        output[output==0] <- NA
    } else {
        output[is.na(output)] <- 0
    }
    return(output)
}

#+end_src

*** windDispGRASS
#+begin_src R :eval nil :tangle ./R/windDispGRASS.R :no-expand
##' Disperses seeds from a input raster layer in GRASS by using a 2 dimensional dispersal kernel \code{matrix}
##' and stores the dispersed seeds in an output layer in RASS
##'
##' This function is a wrapper around \code{windDisp} to facilitate the usage of GRASS as a backend.
##' It retrieves the raster from GRASS and stores the resulting layer in GRASS again.
##'
##' The MASK in GRASS is respected.
##' 
##' @usage windDispGRASS(SD2D, input, output="windDispSeeds", zeroToNULL = TRUE, overwrite=FALSE)
##' @name windDispGRASS
##' @title Dispersal of seeds by wind
##' @param SD2D Sedd Dispersal kernel 2D - \code{matrix} defining the 2D seed dispersal kernel 
##' @param input name of GRASS raster layer specifying number of seeds to be dispersed - \code{character} 
##' @param output name of GRASS raster layer generated, containing the dispersed seeds - \code{character} 
##' @param zeroToNULL \code{boolean} if TRUE replace 0 with NA in the returned \code{matrix},
##' otherwise all NA will be replaced with 0
##' @param overwrite \code{boolean} if TRUE, \code{output} will be overwritten if it exists
##' 
##' @return invisibly \code{character} name of the output layer
##' @author Rainer M Krug \email{Rainer@@krugs.de}
##' @export 
windDispGRASS <- function(
    SD2D,
    input,
    output = "windDispSeeds",
    zeroToNULL = TRUE,
    overwrite = FALSE
    ) {
    if ( length( execGRASS("g.mlist", type="rast", pattern=output, intern=TRUE) ) & !overwrite ) {
        stop(paste("Layer", output, "exists! Please specify 'overwrite=TRUE' or use different output name!"))
    } 
    ##
    seeds <- readRAST(
        c(
            input,
            "MASK"
            ),
        NODATA=-1
        )
    ## seeds.m <- sgdfToMatrix(seeds, 1)
    seeds.m <- matrix(
        seeds[[1]],
        nrow=gridparameters(seeds)$cells.dim[1],
        ncol=gridparameters(seeds)$cells.dim[2])
    ## mask.m <- sgdfToMatrix(seeds, 2)
    mask.m <- matrix(
        seeds[[2]],
        nrow=gridparameters(seeds)$cells.dim[1],
        ncol=gridparameters(seeds)$cells.dim[2])
    
    dispSeeds.m <- windDisp(
        SD2D = SD2D,
        SEEDS = seeds.m,
        MASK = mask.m,
        zeroToNULL = zeroToNULL
        )
    
    seeds@data[[2]] <- as.vector(dispSeeds.m)
    
    mode(seeds[[2]]) <- "double"
    ## seeds@proj4string <- parameter$proj4string
    writeRAST(
        seeds,
        output,
        NODATA = -1,
        zcol=2,
        overwrite = TRUE
        )
    invisible(output)
}
#+end_src

** Local dispersal
*** localDispGRASS
#+begin_src R  :eval nil :tangle ./R/localDispGRASS.R :no-expand
##' Disperses seeds locally, i.e. in neighbouring cells, from an input raster layer in GRASS
##' and stores the dispersed seeds in an output layer in GRASS
##'
##' The seeds in the \code{input} layer are dispersed from each cell into the neighbouring layers following these
##' likelihoods:
##' 
#'' \preformatted{
#'' +------+------+------+
#'' | 1/16 | 1/16 | 1/16 |
#'' +------+------+------+
#'' | 1/16 | 8/16 | 1/16 |
#'' +------+------+------+
#'' | 1/16 | 1/16 | 1/16 |
#'' +------+------+------+
#'' }
##'
##' The resulting seed layer is saved and, if it exists and \code{overwrite==TRUE}, overwritten.
##'
##' The MASK in GRASS is respected.
##' 
##' @usage localDispGRASS(input, output = "localDispSeeds", zeroToNULL = TRUE, overwrite = FALSE)
##' @name localDispGRASS
##' @title Dispersal of seeds in neighbouring cells
##' @param input name of GRASS raster layer specifying number of seeds to be dispersed - \code{character}
##' @param output name of GRASS raster layer generated, containing the dispersed seeds - \code{character} 
##' @param zeroToNULL \code{boolean} if TRUE replace 0 with NA in the returned \code{matrix},
##' otherwise all NA will be replaced with 0
##' @param overwrite \code{boolean} if TRUE, \code{output} will be overwritten if it exists
##' 
##' @return invisibly \code{character} name of the output layer
##' @author Rainer M Krug \email{Rainer@@krugs.de}
##' @export 
localDispGRASS <- function(
    input,
    output = "localDispSeeds",
    zeroToNULL = TRUE,
    overwrite = FALSE
    ) {
    if ( length( execGRASS("g.mlist", type="rast", pattern=output, intern=TRUE) )  & !overwrite ) {
        stop(paste("Layer", output, "exists! Please specify 'overwrite=TRUE' or use different output name!"))
    } 
    r.mapcalc <- function(...)
        {
            comm <- paste( "r.mapcalc ", " \"", ..., "\" ", sep="" )
            system( comm, intern=TRUE )
        }
    ## temporary layer name
    tmp <- "TMP"
    ## calculate 16th of to be dispersed seeds and set nulls to 0
    r.mapcalc(
        tmp,
        " = ",
        "double( ", input, " / 16 )"
        ## 8/16 will remain in source cell,
        ## 8/16 will be evenly distributed in neighbouring cells
        )
    execGRASS(
        "r.null",
        map  = tmp,
        null = 0
        )
    ## Local Dispersal of all seeds in input
    r.mapcalc(
        output,
        " = ",
        "double( round(", 
        tmp, "[-1,-1] + ",
        tmp, "[-1, 0] + ",
        tmp, "[-1, 1] + ",
        tmp, "[ 0,-1] + ",
        " 8 * ", tmp, "[ 0, 0] + ",
        tmp, "[ 0, 1] + ",
        tmp, "[ 1,-1] + ",
        tmp, "[ 1, 0] + ",
        tmp, "[ 1, 1]",
        " ) )"
        )
    ## remove tmp
    execGRASS(
        cmd = "g.remove",
        rast = tmp
        )
    ## if zeroToNULL
    if (zeroToNULL) {
        execGRASS(
            "r.null",
            map=output,
            setnull="0"
            )
    } else {
        execGRASS(
            "r.null",
            map=output,
            null=0
            )    
    }
    ## return name of output layer
    invisible(output)
} 

#+end_src

** Bird dispersal
*** birdDispGRASS
#+begin_src R  :eval nil :tangle ./R/birdDispGRASS.R :no-expand
##' Seed dispersal by birds from a seed layer using GRASS
##'
##' This is a "dumb" implementation of sedd dispersal by birds, simply randomly distributing
##' all seeds in the output raster.
##' 
##' The resulting seed layer is saved and, if it exists and \code{overwrite==TRUE}, overwritten.
##'
##' The MASK in GRASS is respected.
##' 
##' @usage birdDispGRASS(input, output, zeroToNULL, overwrite)
##' @name birdDispGRASS
##' @title Dispersal of seeds by birds
##' 
##' @param input name of GRASS raster layer specifying number of seeds to be dispersed - \code{character}
##' @param output name of GRASS raster layer generated, containing the dispersed seeds - \code{character} 
##' @param zeroToNULL \code{boolean} if TRUE replace 0 with NA in the returned \code{matrix}, otherwise all NA will be replaced with 0
##' @param overwrite \code{boolean} if TRUE, \code{output} will be overwritten if it exists
##' 
##' @return invisibly \code{character} name of the output layer
##' @author Rainer M Krug \email{Rainer@@krugs.de}
##' @export 
birdDispGRASS <- function(
    input,
    output = "birdDispSeeds",
    zeroToNULL = TRUE,
    overwrite = FALSE
    ) {
    if ( length( execGRASS("g.mlist", type="rast", pattern=output, intern=TRUE) )  & !overwrite ) {
        stop(paste("Layer", output, "exists! Please specify 'overwrite=TRUE' or use different output name!"))
    } 
    MASK <- "MASK"
    seeds <- readRAST(
        c(
            input,
            MASK
            ),
        NODATA=-1
        )
    oldWarn <- options()$warn
    options(warn=-1)
    seeds[[3]] <- 0
    seeds[[3]][!is.na(seeds[[MASK]])] <- rmultinom(
        n = 1,
        size = sum(seeds[[input]], na.rm=TRUE),
        prob = rep(1, length.out=sum(!is.na(seeds[[MASK]])))
        )
    ## seeds[[3]][!is.na(seeds[[MASK]])] <- rbinom(                                     # Bird dispersal
    ##                                             cells <- sum(!is.na(seeds[[MASK]])), # into all cells which are not NULL in the region
    ##                                             sum(seeds[[input]], na.rm=TRUE),     # seeds to disperse
    ##                                             1/cells                              # probability is the same for each cell
    ## )
    options(warn=oldWarn)

    if (zeroToNULL) {
        seeds[[3]][seeds[[3]]==0] <- NA
    } else {
        seeds[[3]][is.na(seeds[[3]])] <- 0
    }
    writeRAST(
        seeds,
        output,
        NODATA = -1,
        zcol=3,
        overwrite = TRUE
        )
    ## return name of output layer
    invisible(output)
} 

#+end_src

** Water dispersal
*** waterDispGRASS
#+begin_src R  :eval nil :tangle ./R/waterDispGRASS.R :no-expand
##' Water disperse seeds from a seed layer using GRASS
##'
##' This function disperses seeds using water dispersal using the raster \code{flowdir} in GRASS agnps format
##' and a raster containing the deposit rates of the seeds for each cell (values rangingfrom 0 to 1).
##' 
##' The principle in this module is as follow:
##' \enumerate{
##' \item create empty output layer
##' \item copy input layer into seedsToBeDispersed
##' \item \bold{repeat}
##' \item calculate seeds which are deposited in each cell based on depRates and add these to the output layer
##' \item subtract the deposited seeds from the seedsToBeDispersed layer
##' \item disperse remaining seeds in each direction separately for each cell
##' \item add up dispersed seeds and store in seedsToBeDispersed
##' \item \bold{until seedsToBeDispersed is empty}
##' \item \bold{end}
##' }
##' 
##' @usage waterDispGRASS(input, output="waterDispSeeds", flowdir, depRates, zeroToNULL = TRUE, overwrite = FALSE)
##' @name waterDispGRASS
##' @title Dispersal of seeds by water
##' 
##' @param input name of GRASS raster layer specifying number of seeds to be dispersed - \code{character} 
##' @param output name of GRASS raster layer generated, containing the dispersed seeds - \code{character} 
##' @param flowdir \code{character} name of GRASS raster containing flow direction (in GRASS agnps format)
##' @param depRates \code{character} name of GRASS raster layer cotaining the deposit rates for each cell.
##' @param zeroToNULL \code{boolean} if TRUE replace 0 with NA in the returned \code{matrix},
##' @param overwrite \code{boolean} TRUE to overwrite existing output raster
##' 
##' @return \code{character} name of the output layer
##' @author Rainer M Krug \email{Rainer@@krugs.de}
##' @export 
waterDispGRASS <- function(
    input,
    output = "waterDispSeeds",
    flowdir,
    depRates,
    zeroToNULL = TRUE,
    overwrite = FALSE
    ) {
    if ( length( execGRASS("g.mlist", type="rast", pattern=output, intern=TRUE) )  & !overwrite ) {
        stop(paste("Layer", output, "exists! Please specify 'overwrite=TRUE' or use different output name!"))
    } 

    ## does one dispersal step and returns
    ## TRUE if executed
    ## FALSE if sum of stepInput is 0, i.e. no seeds to disperse
    oneStep <- function(stepInput, stepDep, stepToDisp, stepFlowdir, stepDepRates) {
        ## calculation of sum of seeds left to be dispersed
        univ <- execGRASS("r.univar", map=stepInput, intern=TRUE)
        sm <- grep("sum", univ, value=TRUE)
        s <- as.numeric(strsplit( sm, split=": " )[[1]][2])
        if ( s <= 0 ) {
            return(FALSE)
        } else {
            ## Calculate seeds to be deposited in cell and set null values to 0
            execGRASS(
                "r.mapcalc",
                expression = paste0(
                    stepDep,
                    " = ",
                    "round(", stepInput, " * ", stepDepRates, ", 1)"
                    )
                )
            execGRASS(
                "r.null",
                map = stepDep,
                null = 0L
                )
            ##
            
            ## Calculate seeds to be dispersed and set null values to 0
            execGRASS(
                "r.mapcalc",
                expression = paste0(
                    "_tmp.wd.disp = ",
                    "max( ", stepInput, " - ", stepDep, ", 0 )"
                    )
                )
            execGRASS(
                "r.null",
                map = "_tmp.wd.disp",
                null = 0L
                )

            ## combine expressions for r.mapcalc
            mce <- paste0(
                "_tmp.wd.into.", 1:8,
                " = ",
                "if( ", stepFlowdir, "[",
                c(1,  1,  0, -1, -1, -1,  0,  1),
                ", ",
                c(0, -1, -1, -1,  0,  1,  1,  1),
                " ] == ", 1:8,
                ", _tmp.wd.disp[ ",
                c(1,  1,  0, -1, -1, -1,  0,  1),
                ", ",
                c(0, -1, -1, -1,  0,  1,  1,  1),
                " ], null() )"
                ) 

            ## calculate all and set null vaues to 0 
            for (i in 1:length(mce)) {
                execGRASS(
                    "r.mapcalc",
                    expression = mce[i]
                    )
                execGRASS(
                    "r.null",
                    map = paste0("_tmp.wd.into.", i),
                    null = 0L
                    )
            }

            ## and finally sum them up
            execGRASS(
                "r.mapcalc",
                expression = paste0(
                    stepToDisp,
                    " = ",
                    paste0("_tmp.wd.into.", c(1:8), collapse = " + ")
                    ),
                flags = "overwrite"
                )
            
            ## and finally delete all temporary layers
            execGRASS(
                "g.mremove",
                rast = "_tmp.wd.*",
                flags = "f"
                )
            return(TRUE)
        }
    }

    ## copy input in temporary input layer
    execGRASS(
        "g.copy",
        rast = paste0(input, ",_tmp.wdout.input")
        )
    ## create empty deposit layer
    execGRASS(
        "r.mapcalc",
        expression = "_tmp.wdout.dep.final = 0"
        )
    while (oneStep("_tmp.wdout.input", "_tmp.wdout.dep", "_tmp.wdout.disp", flowdir, depRates)) {
        univ <- execGRASS("r.univar", map="_tmp.wdout.input", intern=TRUE)
        sm <- grep("sum", univ, value=TRUE)
        paste("############", as.numeric(strsplit( sm, split=": " )[[1]][2]), "############")
        ## copy still to be dispersed seeds into temporary input layer
        execGRASS(
            "g.copy",
            rast = "_tmp.wdout.disp,_tmp.wdout.input",
            flags = "overwrite"
            )
        ## add the deposited seeds to the final deposit layer
        execGRASS(
            "r.mapcalc",
            expression = "_tmp.wdout.dep.final = _tmp.wdout.dep.final + _tmp.wdout.dep",
            flags = "overwrite"
            )
        ## remove _tmp.wdout.dep
        execGRASS(
            "g.remove",
            rast = "_tmp.wdout.dep",
            flags = "f"
            )
        ## and continue, i.e. execute oneStep() and repeat until oneStep returns FALSE
        ## Then nothing needs to be done anymore
    }  
   
    ## set 0 values to null and write temporary layer to output layer
    execGRASS(
        "r.null",
        map = "_tmp.wdout.dep.final",
        setnull = "0"
        )
    execGRASS(
        "g.copy",
        rast = paste0("_tmp.wdout.dep.final", ",", output),
        flags = "overwrite"
        )
    ## and delete temporary layers
    execGRASS(
        "g.mremove",
        rast = "_tmp.wdout.*",
        flags = "f"
        )
    ## if zeroToNULL
    if (zeroToNULL) {
        execGRASS(
            "r.null",
            map=output,
            setnull="0"
            )
    } else {
        execGRASS(
            "r.null",
            map=output,
            null=0
            )    
    }
    invisible(output)
}

#+end_src

* src directory (./src)
:PROPERTIES:
:no-expand: true
:END:
** Makevars
#+begin_src sh :results silent :tangle ./src/Makevars :eval nil
  ## Use the R_HOME indirection to support installations of multiple R version
  PKG_LIBS = `$(R_HOME)/bin/Rscript -e "Rcpp:::LdFlags()"`
  
  ## As an alternative, one can also add this code in a file 'configure'
  ##
  ##    PKG_LIBS=`${R_HOME}/bin/Rscript -e "Rcpp:::LdFlags()"`
  ## 
  ##    sed -e "s|@PKG_LIBS@|${PKG_LIBS}|" \
  ##        src/Makevars.in > src/Makevars
  ## 
  ## which together with the following file 'src/Makevars.in'
  ##
  ##    PKG_LIBS = @PKG_LIBS@
  ##
  ## can be used to create src/Makevars dynamically. This scheme is more
  ## powerful and can be expanded to also check for and link with other
  ## libraries.  It should be complemented by a file 'cleanup'
  ##
  ##    rm src/Makevars
  ##
  ## which removes the autogenerated file src/Makevars. 
  ##
  ## Of course, autoconf can also be used to write configure files. This is
  ## done by a number of packages, but recommended only for more advanced users
  ## comfortable with autoconf and its related tools.
  
  
#+end_src

** Makevars.win
#+begin_src sh :results silent :tangle ./src/Makevars.win :eval nil
  ## Use the R_HOME indirection to support installations of multiple R version
  PKG_LIBS = $(shell "${R_HOME}/bin${R_ARCH_BIN}/Rscript.exe" -e "Rcpp:::LdFlags()")
#+end_src
** windDispCpp.h
#+begin_src c++ :tangle ./src/windDispCpp.h
  #ifndef _test_WINDDISPCPP_H
  #define _test_WINDDISPCPP_H
  
  #include <Rcpp.h>
  
  /*
   * note : RcppExport is an alias to `extern "C"` defined by Rcpp.
   *
   * It gives C calling convention to the rcpp_hello_world function so that 
   * it can be called from .Call in R. Otherwise, the C++ compiler mangles the 
   * name of the function and .Call can't find it.
   *
   * It is only useful to use RcppExport when the function is intended to be called
   * by .Call. See the thread http://thread.gmane.org/gmane.comp.lang.r.rcpp/649/focus=672
   * on Rcpp-devel for a misuse of RcppExport
   */
  
  RcppExport SEXP windDispCpp( SEXP DX2, SEXP DY2, SEXP SD2D, SEXP SEEDS, SEXP MASK) ;
  
  // definition
  
  #endif
  
#+end_src

** windDispCpp.cpp
#+BEGIN_SRC c++ :tangle ./src/windDispCpp.cpp
#include "windDispCpp.h"
  
SEXP windDispCpp( SEXP DX2, SEXP DY2, SEXP SD2D, SEXP SEEDS, SEXP MASK ){
  using namespace Rcpp;
  
  // The input parameter  
  int dx2 = as<int>(DX2); // by reference or value?
  int dy2 = as<int>(DY2);
  NumericVector sd2D (SD2D); // by reference!
  IntegerMatrix seeds (SEEDS);
  IntegerMatrix mask (MASK);
  
  // result vector
  IntegerMatrix dispSeeds = clone<IntegerMatrix>(mask);

  // internal variables
  IntegerVector s (sd2D.size());
  RNGScope scope;                 // N.B. Needed when calling random number generators

  int res; 
  int nc = dispSeeds.ncol();
  int nr = dispSeeds.nrow();

  // BEGIN loop over seeds grid ("moving")
  for( int y=0; y < nc; y++ ){
    for( int x=0; x < nr; x++ ){
      // if dispBEGIN loop over sd2D ("window")
      // #### begin if MASK <> NA
      if ( dispSeeds(x, y) >= 0 ) { 
        int indS = 0;
        // loop ofer 2d2D and copy values into s
        for( int xS=x; xS <= x + dx2; xS++ ){
          for( int yS=y; yS <= y + dy2; yS++, indS++) {
            if ( mask(xS, yS) >= 0){ 
              s[indS]=seeds(xS, yS);
            } else {
              s[indS]=-1;
            }
          }
        }
        res = 0;
        // for each element in s draw binom and sum up
        for( int i=0; i<s.size(); i++ ){
          if (s[i]>0 && sd2D[i]>0) {
            res += (int) ::Rf_rbinom((double)(s[i]), sd2D[i]);
          }
        }
        // copy resulting number of seds into dispSeeds(x,y)
        dispSeeds(x, y) = res;
      }
      // #### end if MASK <> NA
    }
  }
  // END loop over seeds
  
  return wrap( dispSeeds );
}
#+END_SRC

* TODO Local tests
** seed disp
#+begin_src R 

#+end_src
* TODO Vignette
Write vignette
* package management                                               :noexport:


** INSTALL package

#+begin_src sh :results output :var rckopts="--library=./Rlib"
  R CMD INSTALL $rckopts pkg
#+end_src

#+results:
: g++ -I/usr/share/R/include   -I"/home/rkrug/R/i486-pc-linux-gnu-library/2.13/Rcpp/include"   -fpic  -O3 -pipe  -g -c windDispCpp.cpp -o windDispCpp.o
: g++ -shared -o seedDisp.so windDispCpp.o -L/home/rkrug/R/i486-pc-linux-gnu-library/2.13/Rcpp/lib -lRcpp -Wl,-rpath,/home/rkrug/R/i486-pc-linux-gnu-library/2.13/Rcpp/lib -L/usr/lib/R/lib -lR


** build package

#+begin_src sh :results output
  R CMD build ./
#+end_src

#+results:
: * checking for file './DESCRIPTION' ... OK
: * preparing 'seedDisp':
: * checking DESCRIPTION meta-information ... OK
: * cleaning src
: * checking for LF line-endings in source and make files
: * checking for empty or unneeded directories
: Removed empty directory 'seedDisp/inst'
: * building 'seedDisp_0.4-13.tar.gz'

** check package
#+begin_src sh :results output
  R CMD check --as-cran  seedDisp_0.4-13.tar.gz
#+end_src



** load library

#+begin_src R :session :results output :var libname=(file-name-directory buffer-file-name)
## customize the next line as needed: 
.libPaths(new = file.path(getwd(),"Rlib") )
require( basename(libname), character.only=TRUE)
#+end_src

#+results:

- this loads the library into an R session
- customize or delete the =.libPaths= line as desired 


: #+begin_src R :session :var libname=(file-name-directory buffer-file-name)
: .libPaths(new = file.path(getwd(),"Rlib") )
: require( basename(libname), character.only=TRUE)
: #+end_src

** grep require( 

- if you keep all your source code in this =.org= document, then you do not
  need to do this - instead just type =C-s require(=
- list package dependencies that might need to be dealt with

#+begin_src sh :results output
grep 'require(' R/*
#+end_src

: #+begin_src sh :results output
: grep 'require(' R/*
: #+end_src

** set up .Rbuildignore and man, R, and Rlib directories

- This document sits in the top level source directory. So, ignore it
  and its offspring when checking, installing and building.
- List all files to ignore under =#+results: rbi=  (including this
  one!). Regular expressions are allowed.
- Rlib is optional. If you want to INSTALL in the system directory,
  you own't need it.

: #+results: rbi
#+results: rbi
: Rpackage.*
: PATCHVERSION
: MAJORVERSION
: MINORVERSION

Only need to run this once (unless you add more ignorable files).

#+begin_src R :results output silent :var rbld=rbi 
dir.create("./seedDisp")
cat(rbld,'\n', file="./.Rbuildignore")
dir.create("./man")
dir.create("./R")
dir.create("./src")
dir.create("./Rlib")
#+end_src

: #+begin_src R :results output silent :var rbld=rbi 
: cat(rbld,'\n', file=".Rbuildignore")
: dir.create("man")
: dir.create("R")
: dir.create("../Rlib")
: #+end_src

* Package structure and src languages                              :noexport:

- The top level directory may contain these files (and others):

| filename    | filetype      |
|-------------+---------------|
| INDEX       | text          |
| NAMESPACE   | R-like script |
| configure   | Bourne shell  |
| cleanup     | Bourne shell  |
| LICENSE     | text          |
| LICENCE     | text          |
| COPYING     | text          |
| NEWS        | text          |
| DESCRIPTION | [[http://www.debian.org/doc/debian-policy/ch-controlfields.html][DCF]]           |
|-------------+---------------|


 
   and subdirectories
| direname | types of files                                   |
|----------+--------------------------------------------------|
| R        | R                                                |
| data     | various                                          |
| demo     | R                                                |
| exec     | various                                          |
| inst     | various                                          |
| man      | Rd                                               |
| po       | poEdit                                           |
| src      | .c, .cc or .cpp, .f, .f90, .f95, .m, .mm, .M, .h |
| tests    | R, Rout                                          |
|----------+--------------------------------------------------|
|          |                                                  |
   
 [[info:emacs#Specifying%20File%20Variables][info:emacs#Specifying File Variables]]

* README.org
:PROPERTIES:
:tangle: README.org
:END:
#+begin_src org
,#+TITLE: seedDisp --- an R package to simulate seed dispersal
,#+DATE: <2013-09-03 Tue>
,#+AUTHOR: Rainer M. Krug
,#+EMAIL: Rainer@krugs.de
,#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
,#+OPTIONS: author:t c:nil creator:comment d:(not LOGBOOK) date:t e:t
,#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil stat:t tags:t
,#+OPTIONS: tasks:t tex:t timestamp:t toc:t todo:t |:t
,#+CREATOR: Emacs 24.3.1 (Org mode 8.0.7)
,#+DESCRIPTION:
,#+EXCLUDE_TAGS: noexport
,#+KEYWORDS:
,#+LANGUAGE: en
,#+SELECT_TAGS: export

The aim  of this package is to collect different seed dispersal routines usable in R to make finding and selecting seed dispersal function in R easier.


#+end_src
