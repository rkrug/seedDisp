# -*- org-babel-tangled-file: t; org-babel-tangle-run-postTangleScript: t; -*-

#+TITLE:     seedDisp.org
#+AUTHOR:    Rainer M Krug
#+EMAIL:     Rainer@krugs.de
#+DESCRIPTION: R Package Development Helpers
#+KEYWORDS: 

:CONFIG:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 

#+TODO: TODO OPTIMIZE TOGET COMPLETE WAIT VERIFY CHECK CODE DOCUMENTATION | DONE RECEIVED CANCELD 

#+STARTUP: indent hidestars nohideblocks
#+DRAWERS: HIDDEN PROPERTIES STATE CONFIG BABEL OUTPUT LATEXHEADER HTMLHEADER
#+STARTUP: nohidestars hideblocks
:END:
:HTMLHEADER:
#+begin_html
  <div id="subtitle" style="float: center; text-align: center;">
  <p>
Org-babel support for building 
  <a href="http://www.r-project.org/">R</a> packages
  </p>
  <p>
  <a href="http://www.r-project.org/">
  <img src="http://www.r-project.org/Rlogo.jpg"/>
  </a>
  </p>
  </div>
#+end_html
:END:
:LATEXHEADER:
#+LATEX_HEADER: \usepackage{rotfloat}
#+LATEX_HEADER: \definecolor{light-gray}{gray}{0.9}
#+LATEX_HEADER: \lstset{%
#+LATEX_HEADER:     basicstyle=\ttfamily\footnotesize,       % the font that is used for the code
#+LATEX_HEADER:     tabsize=4,                       % sets default tabsize to 4 spaces
#+LATEX_HEADER:     numbers=left,                    % where to put the line numbers
#+LATEX_HEADER:     numberstyle=\tiny,               % line number font size
#+LATEX_HEADER:     stepnumber=0,                    % step between two line numbers
#+LATEX_HEADER:     breaklines=true,                 %!! don't break long lines of code
#+LATEX_HEADER:     showtabs=false,                  % show tabs within strings adding particular underscores
#+LATEX_HEADER:     showspaces=false,                % show spaces adding particular underscores
#+LATEX_HEADER:     showstringspaces=false,          % underline spaces within strings
#+LATEX_HEADER:     keywordstyle=\color{blue},
#+LATEX_HEADER:     identifierstyle=\color{black},
#+LATEX_HEADER:     stringstyle=\color{green},
#+LATEX_HEADER:     commentstyle=\color{red},
#+LATEX_HEADER:     backgroundcolor=\color{light-gray},   % sets the background color
#+LATEX_HEADER:     columns=fullflexible,  
#+LATEX_HEADER:     basewidth={0.5em,0.4em}, 
#+LATEX_HEADER:     captionpos=b,                    % sets the caption position to `bottom'
#+LATEX_HEADER:     extendedchars=false              %!?? workaround for when the listed file is in UTF-8
#+LATEX_HEADER: }
:END:
:BABEL:
#+PROPERTY: exports code
#+PROPERTY: comments yes
#+PROPERTY: padline no
#+PROPERTY: var MAJORVERSION=0
#+PROPERTY: var+ MINORVERSION=4
#+PROPERTY: var+ PATCHVERSION=13
#+PROPERTY: var+ GITHASH="testhash" 
#+PROPERTY: var+ GITCOMMITDATE="testdate"
:END:

* Internal configurations                      :noexport:
** Evaluate to run post tangle script
#+begin_src emacs-lisp :results silent :tangle no :exports none
  (add-hook 'org-babel-post-tangle-hook
            (
             lambda () 
                    (call-process-shell-command "./postTangleScript.sh" nil 0 nil)
  ;;              (async-shell-command "./postTangleScript.sh")
  ;;              (ess-load-file (save-window-excursion (replace-regexp-in-string ".org" ".R" buffer-file-name)))))
  ;;              (ess-load-file "nsa.R")))
  ;;              (ess-load-file "spreadSim.R")
                    )
            )
#+end_src

** Post tangle script
:PROPERTIES:
:tangle: postTangleScript.sh
:END:
#+begin_src sh :tangle postTangleScript.sh
  sed -i '' s/MAJORVERSION/$MAJORVERSION/ ./DESCRIPTION
  sed -i '' s/MINORVERSION/$MINORVERSION/ ./DESCRIPTION
  sed -i '' s/PATCHVERSION/$PATCHVERSION/ ./DESCRIPTION
  sed -i '' s/TODAYSDATE/`date +%Y-%m-%d_%H-%M`/ ./DESCRIPTION

  sed -i '' s/MAJORVERSION/$MAJORVERSION/ ./seedDisp-package.R
  sed -i '' s/MINORVERSION/$MINORVERSION/ ./seedDisp-package.R
  sed -i '' s/PATCHVERSION/$PATCHVERSION/ ./seedDisp-package.R
  sed -i '' s/TODAYSDATE/`date +%Y-%m-%d_%H-%M`/ ./seedDisp-package.R

  Rscript -e "library(roxygen2);roxygenize('.', copy.package=FALSE, unlink.target=FALSE)"
  # rm -f ./postTangleScript.sh
#+end_src

#+RESULTS:


* gitignore file (./.gitignore)
:PROPERTIES:
:tangle: ./.gitignore
:comments: no
:no-expand: TRUE
:shebang:
:padline: no
:END: 
#+begin_src gitignore
.#*
#*
,*#
,*~
,*#seedDisp.*
seedDisp.*
!seedDisp.org*
,*.o
,*.so
,*.rds
/postTangleScript.sh
#+end_src

* Git Revision info
Complete version info
#+begin_src sh :exports results :results output replace 
  echo "Version     : " $MAJORVERSION.$MINORVERSION-$PATCHVERSION
  echo "Commit date : " `git show -s --format="%ci" HEAD`
  echo "git HASH    : " `git rev-parse HEAD`
  echo "git status  : "
  git status
#+end_src

#+RESULTS:
#+begin_example
Version     :  0.4-13
Commit date :  2013-08-06 11:50:57 +0200
git HASH    :  4b874b68a6e5159eab8e2c1206c809958fa554eb
git status  : 
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   .gitignore
#	modified:   seedDisp.org
#
#+end_example



* Rbuildignore file (./.Rbuildignore)
:PROPERTIES:
:tangle: ./.Rbuildignore
:comments: no
:no-expand: TRUE
:shebang:
:padline: no
:END: 
#+begin_src fundamental
  .git
  ^.*\\.org$
  ^seedDisp.
  .gitignore
  library
  version
  postTangleScript.sh
#+end_src



* Package description
#+begin_src R :eval nil :tangle ./seedDisp-package.R :shebang :padline no :no-expand :comments no
  ##' Disperses seeds by using different routines
  ##' 
  ##' \tabular{ll}{
  ##' Package: \tab seedDisp\cr
  ##' Type: \tab Package\cr
  ##' Version: \tab MAJORVERSION.MINORVERSION.PATCHVERSION\cr
  ##' Date: \tab TODAYSDATE\cr
  ##' License: \tab GPL (>= 2)\cr
  ##' LazyLoad: \tab yes\cr
  ##' }
  ##'
  ##' @docType package
  ##' @author Rainer M Krug \email{Rainer@@krugs.de}
  NULL
#+end_src

* Package Files
** DESCRIPTION
:PROPERTIES:
:tangle:   ./DESCRIPTION
:padline: no 
:no-expand: TRUE
:comments: no
:END:
#+begin_src fundamental
Package: seedDisp
Type: Package
Title: Dispersal of seed routines
Version: MAJORVERSION.MINORVERSION-PATCHVERSION
Date: TODAYSDATE
Author: Rainer M. Krug
Maintainer: Rainer M Krug <Rainer@krugs.de>
Description: Collection of different seed dispersal routines.
License: GPL-3
LazyLoad: yes
Depends: Rcpp (>= 0.9.4), spgrass6
LinkingTo: Rcpp  
#+end_src

** NAMESPACE
:PROPERTIES:
:tangle:   ./NAMESPACE
:padline: no 
:no-expand: TRUE
:comments: no
:END:
#+begin_src R
  useDynLib(seedDisp)
  exportPattern("^[[:alpha:]]+")
#+end_src

#+results:


* R directory (./R)
** Wind dispersal
*** windDisp
#+begin_src R :eval nil :tangle ./R/windDisp.R :no-expand
##' Disperses seeds from a matrix by using a 2 dimensional dispersal kernel
##'
##' This function uses a 2D seed dispersal kernel in form of a \code{matrix} to disperse seeds
##' from a seed source in form of a \code{matrix} and returns a \code{matrix} of the same size
##' containing the seed distribnution after the seeds in the original seed matrix are dispersed.
##' 
##' The function uses an inverse approach, by going over all cells and determining the number of
##' seeds dispersed \bold{into} the cell from all the cells under the dispersel kernel.
##' To calculate the number of seeds dispersed into each cell, the foolowing steps are done:
##' 
##' 1) The dispersal kernel is centered over the for which the number of seeds to be dispersed into
##' will be calculated
##' 
##' 2) for each cell under the dispersal kernel \code{SD2D} the following is done
##' 
##' 2.1) if the corresponding cell in MASK is \code{NA}, no seeds are dispersed into this cell
##' 
##' 2.2) for each cell under the kernel \code{SD2D} for which the underlying MASK is not NA a binominal distributed random number is drawn with
##' 
##'         \code{rbinom(1, noOfSeeds, prob)} \cr
##'         \code{noOfSeeds} : number of seeds in the cell from which the seeds orriginate \cr
##'         \code{prob} : probability from \code{SD2D} kernel of the corresponding cell
##' 
##'      and summed up for the whole kernel.
##' 
##' This function is implemented in C (\code{windDispCpp})
##'
##' The C function requires the seed raster to be buffered by half
##' the width of the seed dispertsal kernel \code{SD2D} which is done
##' in the function before calling the C function.
##' 
##' 
##' @usage windDisp(SD2D, SEEDS, MASK)
##' @name windDisp
##' @title Dispersal of seeds by wind
##' @param SD2D Sedd Dispersal kernel 2D - \code{matrix} defining the 2D seed dispersal kernel 
##' @param SEEDS \code{matrix} specifying the number of seeds to be dispersed
##' @param MASK \code{matrix} defining the area in which processing takes place (\code{!is.na(MASK)}) 
##' @param zeroToNULL \code{boolean} if TRUE replace 0 with NA in the returned \code{matrix}, 
##' otherwise all NA will be replaced with 0
##' 
##' @return \code{matrix} of same size as \code{SEEDS} containing the dispersed seeds
##' @author Rainer M Krug \email{Rainer@@krugs.de}
##' 
##' @useDynLib seedDisp
##' @export 

windDisp <- function(SD2D, SEEDS, MASK, zeroToNULL) {
    ## Calculate size parameter of sd2D
    dx2 <- (ncol(SD2D) - 1)
    dy2 <- (nrow(SD2D) - 1)
    dx <- dx2 / 2
    dy <- dy2 / 2
    ## buffer MASK and SEEDS for dispersal into cells at the edge
    buffer <- matrix(NA, nrow=nrow(SEEDS), ncol=dx)
    SEEDS <- cbind(buffer, SEEDS, buffer)
    MASK <- cbind(buffer, MASK, buffer)
    buffer <- matrix(NA, ncol=ncol(SEEDS), nrow=dy)
    SEEDS <- rbind(buffer, SEEDS, buffer)
    MASK <- rbind(buffer, MASK, buffer)
    ## call C++ function
    output <- .Call(
        "windDispCpp",
        dx2,
        dy2,
        SD2D,
        SEEDS,
        MASK,
        PACKAGE = "seedDisp"
        )
    if (zeroToNULL) {
        output[output==0] <- NA
    } else {
        output[is.na(output)] <- 0
    }
    return(output)
}

#+end_src

*** windDispGRASS
#+begin_src R :eval nil :tangle ./R/windDispGRASS.R :no-expand
##' Disperses seeds from a input raster layer in GRASS by using a 2 dimensional dispersal kernel \code{matrix}
##' and stores the dispersed seeds in an output layer in RASS
##'
##' This function is a wrapper around \code{windDisp} to facilitate the usage of GRASS as a backend.
##' It retrieves the raster from GRASS and stores the resulting layer in GRASS again.
##'
##' The MASK in GRASS is respected.
##' 
##' @usage windDisp(SD2D, input, output="windDispSeeds", overwrite=FALSE)
##' @name windDispGRASS
##' @title Dispersal of seeds by wind
##' @param SD2D Sedd Dispersal kernel 2D - \code{matrix} defining the 2D seed dispersal kernel 
##' @param input name of GRASS raster layer specifying number of seeds to be dispersed - \code{character} 
##' @param output name of GRASS raster layer generated, containing the dispersed seeds - \code{character} 
##' @param zeroToNULL \code{boolean} if TRUE replace 0 with NA in the returned \code{matrix},
##' otherwise all NA will be replaced with 0
##' @param overwrite \code{boolean} if TRUE, \code{output} will be overwritten if it exists
##' 
##' @return invisibly \code{character} name of the output layer
##' @author Rainer M Krug \email{Rainer@@krugs.de}
##' @export 
windDispGRASS <- function(
    SD2D,
    input,
    output = "windDispSeeds",
    zeroToNULL = TRUE,
    overwrite = FALSE
    ) {
    if ( length( execGRASS("g.mlist", type="rast", pattern=output, intern=TRUE) ) & !overwrite ) {
        stop(paste("Layer", output, "exists! Please specify 'overwrite=TRUE' or use different output name!"))
    } 
    ##
    seeds <- readRAST6(
        c(
            input,
            "MASK"
            ),
        NODATA=-1
        )
    ## seeds.m <- sgdfToMatrix(seeds, 1)
    seeds.m <- matrix(
        seeds[[1]],
        nrow=gridparameters(seeds)$cells.dim[1],
        ncol=gridparameters(seeds)$cells.dim[2])
    ## mask.m <- sgdfToMatrix(seeds, 2)
    mask.m <- matrix(
        seeds[[2]],
        nrow=gridparameters(seeds)$cells.dim[1],
        ncol=gridparameters(seeds)$cells.dim[2])
    
    dispSeeds.m <- windDisp(
        SD2D = SD2D,
        SEEDS = seeds.m,
        MASK = mask.m,
        zeroToNULL = zeroToNULL
        )
    
    seeds@data[[2]] <- as.vector(dispSeeds.m)
    
    mode(seeds[[2]]) <- "double"
    ## seeds@proj4string <- parameter$proj4string
    writeRAST6(
        seeds,
        output,
        NODATA = -1,
        zcol=2,
        overwrite = overwrite
        )
    invisible(output)
}
#+end_src

** Local dispersal
*** localDispGRASS
#+begin_src R  :eval nil :tangle ./R/localDispGRASS.R :no-expand
##' Disperses seeds locally, i.e. in neighbouring cells, from an input raster layer in GRASS
##' and stores the dispersed seeds in an output layer in GRASS
##'
##' The seeds in the \code{input} layer are dispersed from each cell into the neighbouring layers following these
##' likelihoods:
##' 
##' \code{\cr
##' +------+------+------+ \cr
##' | 1/16 | 1/16 | 1/16 | \cr
##' +------+------+------+ \cr
##' | 1/16 | 8/16 | 1/16 | \cr
##' +------+------+------+ \cr
##' | 1/16 | 1/16 | 1/16 | \cr
##' +------+------+------+ \cr
##' }
##'
##' The resulting seed layer is saved and, if it exists and \code{overwrite==TRUE}, overwritten.
##'
##' The MASK in GRASS is respected.
##' 
##' @usage localDispGRASS(input, output, overwrite)
##' @name localDispGRASS
##' @title Dispersal of seeds in neighbouring cells
##' @param input name of GRASS raster layer specifying number of seeds to be dispersed - \code{character}
##' @param output name of GRASS raster layer generated, containing the dispersed seeds - \code{character} 
##' @param zeroToNULL \code{boolean} if TRUE replace 0 with NA in the returned \code{matrix},
##' otherwise all NA will be replaced with 0
##' @param overwrite \code{boolean} if TRUE, \code{output} will be overwritten if it exists
##' 
##' @return invisibly \code{character} name of the output layer
##' @author Rainer M Krug \email{Rainer@@krugs.de}
##' @export 
localDispGRASS <- function(
    input,
    output = "localDispSeeds",
    zeroToNULL = TRUE,
    overwrite = FALSE
    ) {
    if ( length( execGRASS("g.mlist", type="rast", pattern=output, intern=TRUE) )  & !overwrite ) {
        stop(paste("Layer", output, "exists! Please specify 'overwrite=TRUE' or use different output name!"))
    } 
    r.mapcalc <- function(...)
        {
            comm <- paste( "r.mapcalc ", " \"", ..., "\" ", sep="" )
            system( comm, intern=TRUE )
        }
    ## temporary layer name
    tmp <- "TMP"
    ## calculate 16th of to be dispersed seeds and set nulls to 0
    r.mapcalc(
        tmp,
        " = ",
        "double( ", input, " / 16 )"
        ## 8/16 will remain in source cell,
        ## 8/16 will be evenly distributed in neighbouring cells
        )
    execGRASS(
        "r.null",
        map  = tmp,
        null = 0
        )
    ## Local Dispersal of all seeds in input
    r.mapcalc(
        output,
        " = ",
        "double( round(", 
        tmp, "[-1,-1] + ",
        tmp, "[-1, 0] + ",
        tmp, "[-1, 1] + ",
        tmp, "[ 0,-1] + ",
        " 8 * ", tmp, "[ 0, 0] + ",
        tmp, "[ 0, 1] + ",
        tmp, "[ 1,-1] + ",
        tmp, "[ 1, 0] + ",
        tmp, "[ 1, 1]",
        " ) )"
        )
    ## remove tmp
    execGRASS(
        cmd = "g.remove",
        rast = tmp
        )
    ## if zeroToNULL
    if (zeroToNULL) {
        execGRASS(
            "r.null",
            map=output,
            setnull="0"
            )
    } else {
        execGRASS(
            "r.null",
            map=output,
            null=0
            )    
    }
    ## return name of output layer
    invisible(output)
} 

#+end_src

** Bird dispersal
*** birdDispGRASS
#+begin_src R  :eval nil :tangle ./R/birdDispGRASS.R :no-expand
##' Seed dispersal by birds from a seed layer using GRASS
##'
##' This is a "dumb" implementation of sedd dispersal by birds, simply randomly distributing
##' all seeds in the output raster.
##' 
##' The resulting seed layer is saved and, if it exists and \code{overwrite==TRUE}, overwritten.
##'
##' The MASK in GRASS is respected.
##' 
##' @usage birdDispGRASS(input, output, zeroToNull, overwrite)
##' @name birdDispGRASS
##' @title Dispersal of seeds by birds
##' 
##' @param input name of GRASS raster layer specifying number of seeds to be dispersed - \code{character}
##' @param output name of GRASS raster layer generated, containing the dispersed seeds - \code{character} 
##' @param zeroToNULL \code{boolean} if TRUE replace 0 with NA in the returned \code{matrix}, otherwise all NA will be replaced with 0
##' @param overwrite \code{boolean} if TRUE, \code{output} will be overwritten if it exists
##' 
##' @return invisibly \code{character} name of the output layer
##' @author Rainer M Krug \email{Rainer@@krugs.de}
##' @export 
birdDispGRASS <- function(
    input,
    output = "birdDispSeeds",
    zeroToNULL = TRUE,
    overwrite = FALSE
    ) {
    if ( length( execGRASS("g.mlist", type="rast", pattern=output, intern=TRUE) )  & !overwrite ) {
        stop(paste("Layer", output, "exists! Please specify 'overwrite=TRUE' or use different output name!"))
    } 
    MASK <- "MASK"
    seeds <- readRAST6(
        c(
            input,
            MASK
            ),
        NODATA=-1
        )
    oldWarn <- options()$warn
    options(warn=-1)
    seeds[[3]] <- 0
    seeds[[3]][!is.na(seeds[[MASK]])] <- rbinom(                                     # Bird dispersal
                                                cells <- sum(!is.na(seeds[[MASK]])), # into all cells which are not NULL in the region
                                                sum(seeds[[input]], na.rm=TRUE),     # seeds to disperse
                                                1/cells                              # probability is the same for each cell
                                                )
    options(warn=oldWarn)
    
    if (zeroToNULL) {
        seeds[[3]][seeds[[3]]==0] <- NA
    } else {
        seeds[[3]][is.na(seeds[[3]])] <- 0
    }
    writeRAST6(
        seeds,
        output,
        NODATA = -1,
        zcol=3,
        overwrite = overwrite
        )
    ## return name of output layer
    invisible(output)
} 

#+end_src

** Water dispersal
*** waterDispGRASS
#+begin_src R  :eval nil :tangle ./R/waterDispGRASS.R :no-expand
##' Water disperse seeds from a seed layer using GRASS
##'
##' This function disperses seeds using water dispersal using the raster \code{flowdir} in GRASS agnps format
##' and a raster containing the deposit rates of the seeds for each cell (values rangingfrom 0 to 1).
##' 
##' The principle in this module is as follow:
##' \enumerate{
##' \item create empty output layer
##' \item copy input layer into seedsToBeDispersed
##' \item \bold{repeat}
##' \item calculate seeds which are deposited in each cell based on depRates and add these to the output layer
##' \item subtract the deposited seeds from the seedsToBeDispersed layer
##' \item disperse remaining seeds in each direction separately for each cell
##' \item add up dispersed seeds and store in seedsToBeDispersed
##' \item \bold{until seedsToBeDispersed is empty}
##' \item \bold{end}
##' }
##' 
##' @usage waterDispGRASS(input, output="waterDispSeeds", slope="SLOPE", flowdir="FLOWDIR", overwrite=FALSE)
##' @name waterDispGRASS
##' @title Dispersal of seeds by water
##' 
##' @param input name of GRASS raster layer specifying number of seeds to be dispersed - \code{character} 
##' @param output name of GRASS raster layer generated, containing the dispersed seeds - \code{character} 
##' @param flowdir \code{character} name of GRASS raster containing flow direction (in GRASS agnps format)
##' @param depRates \code{character} name of GRASS raster layer cotaining the deposit rates for each cell.
##' @param zeroToNULL \code{boolean} if TRUE replace 0 with NA in the returned \code{matrix},
##' @param overwrite \code{boolean} TRUE to overwrite existing output raster
##' 
##' @return \code{character} name of the output layer
##' @author Rainer M Krug \email{Rainer@@krugs.de}
##' @export 
waterDispGRASS <- function(
    input,
    output = "waterDispSeeds",
    flowdir,
    depRates,
    zeroToNull = TRUE,
    overwrite = FALSE
    ) {
    if ( length( execGRASS("g.mlist", type="rast", pattern=output, intern=TRUE) )  & !overwrite ) {
        stop(paste("Layer", output, "exists! Please specify 'overwrite=TRUE' or use different output name!"))
    } 

    ## does one dispersal step and returns
    ## TRUE if executed
    ## FALSE if sum of stepInput is 0, i.e. no seeds to disperse
    oneStep <- function(stepInput, stepDep, stepToDisp, stepFlowdir, stepDepRates) {
        ## calculation of sum of seeds left to be dispersed
        univ <- execGRASS("r.univar", map=stepInput, intern=TRUE)
        sm <- grep("sum", univ, value=TRUE)
        s <- as.numeric(strsplit( sm, split=": " )[[1]][2])
        if ( s <= 0 ) {
            return(FALSE)
        } else {
            ## Calculate seeds to be deposited in cell and set null values to 0
            execGRASS(
                "r.mapcalc",
                expression = paste0(
                    stepDep,
                    " = ",
                    "round(", stepInput, " * ", stepDepRates, ", 1)"
                    )
                )
            execGRASS(
                "r.null",
                map = stepDep,
                null = 0L
                )
            ##
            
            ## Calculate seeds to be dispersed and set null values to 0
            execGRASS(
                "r.mapcalc",
                expression = paste0(
                    "_tmp.wd.disp = ",
                    "max( ", stepInput, " - ", stepDep, ", 0 )"
                    )
                )
            execGRASS(
                "r.null",
                map = "_tmp.wd.disp",
                null = 0L
                )

            ## combine expressions for r.mapcalc
            mce <- paste0(
                "_tmp.wd.into.", 1:8,
                " = ",
                "if( ", stepFlowdir, "[",
                c(1,  1,  0, -1, -1, -1,  0,  1),
                ", ",
                c(0, -1, -1, -1,  0,  1,  1,  1),
                " ] == ", 1:8,
                ", _tmp.wd.disp[ ",
                c(1,  1,  0, -1, -1, -1,  0,  1),
                ", ",
                c(0, -1, -1, -1,  0,  1,  1,  1),
                " ], null() )"
                ) 

            ## calculate all and set null vaues to 0 
            for (i in 1:length(mce)) {
                execGRASS(
                    "r.mapcalc",
                    expression = mce[i]
                    )
                execGRASS(
                    "r.null",
                    map = paste0("_tmp.wd.into.", i),
                    null = 0L
                    )
            }

            ## and finally sum them up
            execGRASS(
                "r.mapcalc",
                expression = paste0(
                    stepToDisp,
                    " = ",
                    paste0("_tmp.wd.into.", c(1:8), collapse = " + ")
                    ),
                flags = "overwrite"
                )
            
            ## and finally delete all temporary layers
            execGRASS(
                "g.mremove",
                rast = "_tmp.wd.*",
                flags = "f"
                )
            return(TRUE)
        }
    }

    ## copy input in temporary input layer
    execGRASS(
        "g.copy",
        rast = paste0(input, ",_tmp.wdout.input")
        )
    ## create empty deposit layer
    execGRASS(
        "r.mapcalc",
        expression = "_tmp.wdout.dep.final = 0"
        )
    while (oneStep("_tmp.wdout.input", "_tmp.wdout.dep", "_tmp.wdout.disp", flowdir, depRates)) {
        univ <- execGRASS("r.univar", map="_tmp.wdout.input", intern=TRUE)
        sm <- grep("sum", univ, value=TRUE)
        paste("############", as.numeric(strsplit( sm, split=": " )[[1]][2]), "############")
        ## copy still to be dispersed seeds into temporary input layer
        execGRASS(
            "g.copy",
            rast = "_tmp.wdout.disp,_tmp.wdout.input",
            flags = "overwrite"
            )
        ## add the deposited seeds to the final deposit layer
        execGRASS(
            "r.mapcalc",
            expression = "_tmp.wdout.dep.final = _tmp.wdout.dep.final + _tmp.wdout.dep",
            flags = "overwrite"
            )
        ## remove _tmp.wdout.dep
        execGRASS(
            "g.remove",
            rast = "_tmp.wdout.dep",
            flags = "f"
            )
        ## and continue, i.e. execute oneStep() and repeat until oneStep returns FALSE
        ## Then nothing needs to be done anymore
    }  
   
    ## set 0 values to null and write temporary layer to output layer
    execGRASS(
        "r.null",
        map = "_tmp.wdout.dep.final",
        setnull = "0"
        )
    if (overwrite) {
        fl <- "overwrite"
    } else {
        fl <- NULL
    }
    execGRASS(
        "g.copy",
        rast = paste0("_tmp.wdout.dep.final", ",", output),
        flags = fl
        )
    ## and delete temporary layers
    execGRASS(
        "g.mremove",
        rast = "_tmp.wdout.*",
        flags = "f"
        )
    ## if zeroToNULL
    if (zeroToNULL) {
        execGRASS(
            "r.null",
            map=output,
            setnull="0"
            )
    } else {
        execGRASS(
            "r.null",
            map=output,
            null=0
            )    
    }
    invisible(output)
}

#+end_src

* src directory (./src)
:PROPERTIES:
:no-expand: true
:END:
** Makevars
#+begin_src sh :results silent :tangle ./src/Makevars :eval nil
  ## Use the R_HOME indirection to support installations of multiple R version
  PKG_LIBS = `$(R_HOME)/bin/Rscript -e "Rcpp:::LdFlags()"`
  
  ## As an alternative, one can also add this code in a file 'configure'
  ##
  ##    PKG_LIBS=`${R_HOME}/bin/Rscript -e "Rcpp:::LdFlags()"`
  ## 
  ##    sed -e "s|@PKG_LIBS@|${PKG_LIBS}|" \
  ##        src/Makevars.in > src/Makevars
  ## 
  ## which together with the following file 'src/Makevars.in'
  ##
  ##    PKG_LIBS = @PKG_LIBS@
  ##
  ## can be used to create src/Makevars dynamically. This scheme is more
  ## powerful and can be expanded to also check for and link with other
  ## libraries.  It should be complemented by a file 'cleanup'
  ##
  ##    rm src/Makevars
  ##
  ## which removes the autogenerated file src/Makevars. 
  ##
  ## Of course, autoconf can also be used to write configure files. This is
  ## done by a number of packages, but recommended only for more advanced users
  ## comfortable with autoconf and its related tools.
  
  
#+end_src

** Makevars.win
#+begin_src sh :results silent :tangle ./src/Makevars.win :eval nil
  ## Use the R_HOME indirection to support installations of multiple R version
  PKG_LIBS = $(shell "${R_HOME}/bin${R_ARCH_BIN}/Rscript.exe" -e "Rcpp:::LdFlags()")
#+end_src
** windDispCpp.h
#+begin_src c++ :tangle ./src/windDispCpp.h
  #ifndef _test_WINDDISPCPP_H
  #define _test_WINDDISPCPP_H
  
  #include <Rcpp.h>
  
  /*
   * note : RcppExport is an alias to `extern "C"` defined by Rcpp.
   *
   * It gives C calling convention to the rcpp_hello_world function so that 
   * it can be called from .Call in R. Otherwise, the C++ compiler mangles the 
   * name of the function and .Call can't find it.
   *
   * It is only useful to use RcppExport when the function is intended to be called
   * by .Call. See the thread http://thread.gmane.org/gmane.comp.lang.r.rcpp/649/focus=672
   * on Rcpp-devel for a misuse of RcppExport
   */
  
  RcppExport SEXP windDispCpp( SEXP DX2, SEXP DY2, SEXP SD2D, SEXP SEEDS, SEXP MASK) ;
  
  // definition
  
  #endif
  
#+end_src

** windDispCpp.cpp
#+BEGIN_SRC c++ :tangle ./src/windDispCpp.cpp
#include "windDispCpp.h"
  
SEXP windDispCpp( SEXP DX2, SEXP DY2, SEXP SD2D, SEXP SEEDS, SEXP MASK ){
  using namespace Rcpp;
  
  // The input parameter  
  int dx2 = as<int>(DX2); // by reference or value?
  int dy2 = as<int>(DY2);
  NumericVector sd2D (SD2D); // by reference!
  IntegerMatrix seeds (SEEDS);
  IntegerMatrix mask (MASK);
  
  // result vector
  IntegerMatrix dispSeeds = clone<IntegerMatrix>(mask);

  // internal variables
  IntegerVector s (sd2D.size());
  RNGScope scope;                 // N.B. Needed when calling random number generators

  int res; 
  int nc = dispSeeds.ncol();
  int nr = dispSeeds.nrow();

  // BEGIN loop over seeds grid ("moving")
  for( int y=0; y < nc; y++ ){
    for( int x=0; x < nr; x++ ){
      // if dispBEGIN loop over sd2D ("window")
      // #### begin if MASK <> NA
      if ( dispSeeds(x, y) >= 0 ) { 
        int indS = 0;
        // loop ofer 2d2D and copy values into s
        for( int xS=x; xS <= x + dx2; xS++ ){
          for( int yS=y; yS <= y + dy2; yS++, indS++) {
            if ( mask(xS, yS) >= 0){ 
              s[indS]=seeds(xS, yS);
            } else {
              s[indS]=-1;
            }
          }
        }
        res = 0;
        // for each element in s draw binom and sum up
        for( int i=0; i<s.size(); i++ ){
          if (s[i]>0 && sd2D[i]>0) {
            res += (int) ::Rf_rbinom((double)(s[i]), sd2D[i]);
          }
        }
        // copy resulting number of seds into dispSeeds(x,y)
        dispSeeds(x, y) = res;
      }
      // #### end if MASK <> NA
    }
  }
  // END loop over seeds
  
  return wrap( dispSeeds );
}
#+END_SRC

* TODO Local tests
** seed disp
#+begin_src R 

#+end_src
* TODO Vignette
Write vignette
* package management                                               :noexport:
** check package
#+begin_src sh :results output
  CWD=`pwd`
  R CMD check . | sed 's/^*/ */'
#+end_src

#+results:
#+begin_example
 * using log directory '/Users/rainerkrug/Documents/Projects/R-Packages/seedDisp/..Rcheck'
 * using R version 3.0.1 (2013-05-16)
 * using platform: x86_64-apple-darwin12.4.0 (64-bit)
 * using session charset: ASCII
 * checking for file './DESCRIPTION' ... OK
 * checking extension type ... Package
 * this is package 'seedDisp' version '0.4-13'
 * checking package namespace information ... OK
 * checking package dependencies ... OK
 * checking if this is a source package ... WARNING
Subdirectory 'seedDisp/src' contains apparent object files/libraries
  seedDisp.so windDispCpp.o
Object files/libraries should not be included in a source package.
 * checking if there is a namespace ... OK
 * checking for executable files ... WARNING
Found the following executable files:
  .git/objects/00/64e54bb4e4ccc0590f7842212c6bd9be10cd6d
  .git/objects/00/efb18ad59c6a2a79d18b7ef7602d8a51f1b5d4
  .git/objects/02/73dcefe4c64204bcac41a93b385d30713bf819
  .git/objects/04/ccdad6b13e450fa7091a462321c91b4dc9a54e
  .git/objects/05/b486d610dd476e4c415fb80f34c43da9679477
  .git/objects/05/c156898c6b48fac8b9e47bc41570b306bd9266
  .git/objects/05/d99118830a7d481e0084a190791f956537968d
  .git/objects/09/aacf2a69bb167b0205a457720e0a82fba4544b
  .git/objects/0a/2982c7a088c84704dcf166dde7bd28e12ed7ef
  .git/objects/0a/e47c50d18847ceeddfe0dcb499dcfea528ee13
  .git/objects/0b/5d8aa750564802141836b18ccaecaa07274e20
  .git/objects/0c/0a05b3bf93a9c6a38b68ea212ea0f42e713448
  .git/objects/0c/1f8ea7d5d97209bb1d68900e511bbace47a7f3
  .git/objects/0c/e275b5d63fd5383cbd220d8ab7778e7252cc5c
  .git/objects/0d/3ead50e0abbfdf7d26072f6f3f96abe1f55828
  .git/objects/0f/ad19656c8bd967e581c683a13ae2f08273ea94
  .git/objects/10/be0c12f36ddd56f6edcb8fe6e8c861b65668cf
  .git/objects/13/2cd10d6113481fadc0622aa8753f93934a1676
  .git/objects/13/3db773b71990d2718d1080ba7a85ee2b368aa1
  .git/objects/16/f3bb09983c97ad869b0f66ca6cba0f88e1afce
  .git/objects/17/507f47b5b92dd0dcdb2a5e82acffe108d4be9d
  .git/objects/1a/381bc2cb98f679d15af23283b35de7d5c51096
  .git/objects/1b/40f1c6345c623bdbcb18fd39d2f00335589081
  .git/objects/1b/4e7381409e7f78115d07ddfbbbcbe3131aefb3
  .git/objects/1b/7ad76ceec522afb42bc8153aa9f079f08c42c7
  .git/objects/1f/b9bf5aeef187304c51204917ec395ec731aac3
  .git/objects/1f/f8c93b84c06730792fc8f7faee7e9bc6dc30db
  .git/objects/21/16f8e445e20d2229cad8a922123d1ed27dde81
  .git/objects/22/34ed9ee3fbb97bb8c66e967409787e18033800
  .git/objects/23/bc15379231b4f4b7d8de6011565138296779c9
  .git/objects/26/d31445a4d25b6f8e8ddb530a240bff491b7b6f
  .git/objects/27/26cff619179de632db0b95bb351f693d983266
  .git/objects/27/5ba042cc14050c363459da241efb0377bd40ca
  .git/objects/27/bdc591d325aa29a5f37073321d4f87564f2842
  .git/objects/27/bee04742a1b5ff9ad0cbf069e519722d9f0c7d
  .git/objects/29/3f9c13a685626464ce17e3a44e14a7531b18ae
  .git/objects/2a/4113303486534ca266fe6fdeee224a36f8775e
  .git/objects/2b/d211fddbe719c19da09c5e3c44574d371c03ee
  .git/objects/2d/b8569e64fdf899cc7d62946f127407e0151238
  .git/objects/30/fb5472a846f1ef04276b426934c1b38fcee0cf
  .git/objects/31/08875338b20c10dd4fa09a6937f41115c5a8ec
  .git/objects/31/13a1dc5d81d559ea7a5069b3a69fc6e0d157cd
  .git/objects/31/bdbb1f440e269dbdacfbd485facf49e435759c
  .git/objects/35/fd13e12659e7a74711a1fdc7e557a34bd46f75
  .git/objects/36/7eb63490acc1f5d8042f172e44927ecb2d0052
  .git/objects/38/5a3f339873e29e92d5c24e90c7142e14118e6d
  .git/objects/3b/6785a30e99eca12010f841d625ab9214dec2b3
  .git/objects/3c/e9eb3adc41b14289517881bfc38711e29465a7
  .git/objects/3d/c1ba5df033328d384563f85a0009f61d08b799
  .git/objects/3d/e9ca973fc5cf35ecc192768b41391c125c8c6b
  .git/objects/3e/332a28394847a1db7e1f75ac59bbdd289471b9
  .git/objects/3e/a68dfaafd1de464788845d367097693a32de57
  .git/objects/41/18990a9776a72108ab036c39ac03fd056e9135
  .git/objects/41/fc35923a1dcb2c36a4c7bc31ad0f8368cf4bb5
  .git/objects/42/b9f0dd683c2d31234a54779b869784c54f373a
  .git/objects/43/9aecd0c56c7e5c1edce21d6d4efbd63f10c2a6
  .git/objects/44/66e16c895ab6e4d2b9d293e9451c4b9401174a
  .git/objects/45/35e561c57e1ccf4471a31caaa57e9e20e7ae55
  .git/objects/47/14ecfe48f06c3a8a7408d8460bc33872db4eae
  .git/objects/47/4cb96e20aa5dce7ae070371d26d6987fa699a6
  .git/objects/47/8f71579ef1e2d05828a657bfb264441afa8e8d
  .git/objects/48/8c7f62bc0e1974cde252ae551b9927bfb0791d
  .git/objects/4b/57e439bc975d104e4b0a52dab708212da17829
  .git/objects/4b/874b68a6e5159eab8e2c1206c809958fa554eb
  .git/objects/4b/f154327e96bb1e6bc2148caab885343f95f696
  .git/objects/4c/7e2bba437618f8394c0629b8258da7151bc3f8
  .git/objects/4c/d0f06f5acb44ba0029dcda6c0ee84516b47a5f
  .git/objects/4d/8447b7f0b81f27750800ac1f6cf77538eb96bb
  .git/objects/4e/d3f34a151dbc5be2720deaf74b8b40170882d8
  .git/objects/4e/f5753b671898fd3500fd2ffd67ebdde4cf658e
  .git/objects/50/109b8e789e25b3e78a2b1e363f628476eec5e6
  .git/objects/51/17eaaaddff0527dbf8849bde97c1fb7fcf1647
  .git/objects/52/a06431fe0b663ced3809dc31e1ee1b85f4e519
  .git/objects/59/d11e8ea3cdea6c97a66fe5f429b8fdc4968d5b
  .git/objects/5a/b2194e3720eba6f14d67f20e1a775981027db8
  .git/objects/5c/26c2eee722f723cabb99d11a73c39de5e38cf0
  .git/objects/5d/8a8f3fee97e57e2d9bf6fb56a5ca2d1eefffff
  .git/objects/5e/0c787b5efb3f89fc1e0acc3a0374389ffa4eb1
  .git/objects/5e/cab9b26e625ce66219aaaa7ada7b59225c88c5
  .git/objects/63/ea8f24e2cc93d2b24f705d9b73991be60b98a4
  .git/objects/64/615f7661e81cf4018e1d2270ca3001a7730a16
  .git/objects/65/73ae8192171ca9d5c9c843da8618d9aab3635f
  .git/objects/66/14b539877041f9f6e8d67ebcdda5abb4253817
  .git/objects/66/a17f0227465d55ee61faf9e8e52b8bea2ad6ec
  .git/objects/6c/01a31bc5e2d696d60170ff27eba9d06d383e4b
  .git/objects/6c/ba183650dfdb3ffed715116dd012fdd91d478b
  .git/objects/6d/f2c5e95e9e003c44f88e2064c40d33ad43b522
  .git/objects/6e/8c9bdd76eaed8ce0d7e89b5008d9cfa2adfdbd
  .git/objects/6e/dc239a5c113fcf805c13208227353bbebc9d9c
  .git/objects/73/97c25f3f210625ae325f2138ee6c438338717a
  .git/objects/74/eeaf356f44536275447e47c472ff1c2d96b906
  .git/objects/77/5df31daac36f880f2cc4dbfbe25d21c1cc2862
  .git/objects/78/484be25f573f8dd62f22922ad6631f133737da
  .git/objects/79/e64337a596b16a960c087602b2fa2aaac3dedd
  .git/objects/7b/391250b50407a38bc7d3f6e860c52b11a4cd96
  .git/objects/7b/66c14126046e553f6dc2ffe5129a059283dfea
  .git/objects/7b/8a4dbc532585148168ba0879970e3f84705107
  .git/objects/7c/cd23ed2ae5bedffd9dffdb281f3cb8ab575b96
  .git/objects/81/8fa3c8915131ef6a461f92e2ca0f92794fa376
  .git/objects/83/6ce2792c46d7df7ff1d9a328508c9a275d21dd
  .git/objects/83/c59d401051fc0c21017da0f2a5f05f216e530c
  .git/objects/84/becd681ff73491273f6a6db02f6291b292d657
  .git/objects/86/3d451540256c1290729f4862a0b63ad77b4c21
  .git/objects/8a/b23927a6d95d1128b39273ef26dd57823409e3
  .git/objects/8a/d97018fea50be5a63848ab08bb63907b3074ac
  .git/objects/8b/0db1cd50e19924479739997b48042d9389acef
  .git/objects/8b/1171c1d40e1c780d84b1930cb44b2df1a500f1
  .git/objects/8b/98289207a3833dfacee6ec8fb3ce5cc39c37ef
  .git/objects/8b/ef343a986710a9be1645295bd4ff7499f5fbc7
  .git/objects/8c/b4b80d6d9accb405eb1a276d67bea9e1bf779e
  .git/objects/8e/2735e20b3f49b080907dd59af713770fdea7d0
  .git/objects/8e/965ae5ed17471b044191d5df6ad7990d644799
  .git/objects/8f/51dfa8acf0a045df41fdb8f2293e2d3aefa02d
  .git/objects/90/23f22380467f6fcaca4ca9e22ea1f6c1bf7da6
  .git/objects/90/6d085c35b4b835082e4583c4134c5ddf7f1555
  .git/objects/91/dbedc936440547314edccc091602a800a18894
  .git/objects/92/ce2d03a2b25ab8f1a93ca6b1cfc850552cb74f
  .git/objects/92/e926bd98b05f3a1f2dd11368afd5c3fa06afa9
  .git/objects/94/a81520cf5641caad0133c044683fea05c68f62
  .git/objects/95/0193fdbc2030aeae2630ced21f0ea550b104a1
  .git/objects/95/1ea8f582ad9d22bf7d1465014fecc9533707fd
  .git/objects/95/26c68ad299a65f78efedf338b084fbc45329bd
  .git/objects/97/761241f44b9c3ad375d1cb5b93f5a8c2bedb07
  .git/objects/98/5b76d13b99e14980c03e8731a0928af9afed59
  .git/objects/98/d311d946fd09df202f29f729e1c9a7033e97f2
  .git/objects/9d/73c74fbc33bd30ad2d07dd09868c5e9603db0e
  .git/objects/a1/1f519e46f6a639adedfb44a072532b056609ba
  .git/objects/a2/b4fc07ee3f95011fc607ac46e628a28bc5b9b6
  .git/objects/a2/fbb05fcef8e47fb7a19e81c168835b0a49d130
  .git/objects/a4/c5416d033e604d2f1c9207bc1c9ff61a63f6c0
  .git/objects/a6/331ec0aeedc7e06bd1fa7b19016c744174e004
  .git/objects/aa/46b7e3f73859f9f7e4aae5b9d93d750cc04bf8
  .git/objects/aa/7da2efb697162be0b2ece07625023266b90441
  .git/objects/ab/e540e4a35b355bd9213b3d53972238c96e97b2
  .git/objects/ad/c5372d205e320137133d8b28acde047e7d675b
  .git/objects/af/c18b60eac6b92dbffacef2726657f030dd9b3d
  .git/objects/b0/ee1339ede2cd5d59e10acac8674d7e79b29b39
  .git/objects/b2/3e4b1b6e7bbe65b157b9abeea8ec1c468b5182
  .git/objects/b3/6271f92b24a9a9fcb1eeba0b0c99d2ffcd8454
  .git/objects/b3/99d52b8a233c0c042c12f31a08f46b4a87aeee
  .git/objects/b4/9b12234d327abc929e71f4116560ee3d0c4115
  .git/objects/b5/0eeb6a67dbaa866a23da43c0b4ef187fb785c5
  .git/objects/b7/83a341c28ee44c46baf6811ffd25261ba8c9ec
  .git/objects/b7/b5f79d5bbcec83fbfbb4acf9f4e82084c67bf0
  .git/objects/b9/285293f6df231341322edc9335ba45bf3737bd
  .git/objects/ba/8e11fc7fce73089e6e23b0daf6f9c21d8b6d73
  .git/objects/bc/2afaf09c2d4bdd9d91f858fe83c37b0124b022
  .git/objects/c0/c27f26265aadf6cae1beaffcca45dc7c1ff4ac
  .git/objects/c1/56a8140cb02f78f633f2ac964034f3a1f18077
  .git/objects/c3/585da79ffa2a0c0167af4814e5f53598203dc6
  .git/objects/c6/85379b6b427da41967d211e8bca55b9f9f93e5
  .git/objects/c7/9a8216942aeffc3ad77942e6f7da406afc323b
  .git/objects/c7/b505a3d0e65bba61e9efdb60971ea69f8093af
  .git/objects/c8/db4ee2c1750a6f22b8bde263edde83f55519c2
  .git/objects/c8/f1a4af255a603ae2ad12a6a730b44aebfc5ffa
  .git/objects/cb/ebc2b9737a9ae3ef4776272746894d622e07f3
  .git/objects/d2/b99f34f4491ff8e98e538603ffec5e25ea5812
  .git/objects/d2/efb7a0305d49ad885ea80d5abae0c8c63b4ee3
  .git/objects/d4/5ff1035a5735efccd537a8b1516bca420d50a1
  .git/objects/d5/d19028eb008f0c89b9483004cbf8599b23f46a
  .git/objects/dc/7dbf68fc6c42c05c0512492e15fcee0336da55
  .git/objects/dd/85db0354361b9d52970cdfc6b075c741d91913
  .git/objects/dd/bde521777641416ca68605fb1b37325a26ce84
  .git/objects/dd/e9330052aa6bd6eb5d1757afd7f072d4f0a05c
  .git/objects/de/932ea9d4e767746abf7f7590ba58b2883f3f5a
  .git/objects/de/b11122afdcb723876be8faa3bb0fc69b69e442
  .git/objects/de/f8d8e55dea80a6597507addec6c52acdc923b0
  .git/objects/e1/31308a12cde2d2a52722223682b56cab77c5bf
  .git/objects/e4/92eb30de3cd5b50bdf66c34da69f256a7e282c
  .git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
  .git/objects/e6/afc430b2a3d56628d805f9696ce4bd4688e37f
  .git/objects/e7/2ef278592ef625acd9b51951b4291fae1bfbe8
  .git/objects/e7/59eb89c59ad10538fd6166f467540eb4e4d94e
  .git/objects/e9/e827dcab6d7201654757e2c31a168e63e54084
  .git/objects/eb/dab962f97c67fd0fa37198b501cdd6eb5a5d15
  .git/objects/ec/beddc737e1ddaaa20003438babfc3fb6dd1460
  .git/objects/ed/af3c7966ca4d1719753ac1c3c70e7540da7b20
  .git/objects/ee/8ad3873134c845f8e1b16bae7ddb9fd7cb4a39
  .git/objects/ee/baabf331400d851298dd78755b4f738b03e970
  .git/objects/ee/e1ba103130f026bb341ce239178ff376b1ded6
  .git/objects/f0/3df4363282aa404515f9146ebbb2c74dcbcc3c
  .git/objects/f2/e6cbaa359956d96332e23bcf311c796f8a6ccb
  .git/objects/f3/48cb2dc464811ff9225fcb18f15eb7b6897bda
  .git/objects/f4/5ea7697a4bbf78ffd7e8e84e3fb350a06530fb
  .git/objects/f5/11780337477194ddf7f7cd78d658c3cdc00734
  .git/objects/f6/d9b6fcedae5d27cb56784068f7c02e360f7be9
  .git/objects/f7/d8b412c2ece00190fad801c19c6e491559dfdf
  .git/objects/f8/00904f5df6ecf8d7852bb17744719ba3be3011
  .git/objects/f8/41665115693e50d752d919184bd49acd66c57f
  .git/objects/fa/b1d2a0d4fbfb13eae817fbc2d193a7bf4a1ca2
  .git/objects/fd/f78f989d0ece4679c75f31054c09596e8d9d73
  .git/objects/fe/68be7accb027c118dc5f1e4aff408b5c14587e
  .git/objects/ff/3baa4e481978f5a9916348612d8539451e50df
Source packages should not contain undeclared executable files.
See section 'Package structure' in the 'Writing R Extensions' manual.
 * checking for hidden files and directories ... NOTE
Found the following hidden files and directories:
  .#seedDisp.org
  .Rhistory
  .git/svn/.metadata
  .git/svn/refs/remotes/git-svn/.rev_map.edb9625f-4e0d-4859-8d74-9fd3b1da38cb
  .gitignore
  ..Rcheck
  .git
These were most likely included in error. See section 'Package
structure' in the 'Writing R Extensions' manual.
 * checking for portable file names ... OK
 * checking for sufficient/correct file permissions ... OK
 * checking whether package 'seedDisp' can be installed ... ERROR
Installation failed.
See '/Users/rainerkrug/Documents/Projects/R-Packages/seedDisp/..Rcheck/00install.out' for details.
#+end_example



** INSTALL package

#+begin_src sh :results output :var rckopts="--library=./Rlib"
  R CMD INSTALL $rckopts pkg
#+end_src

#+results:
: g++ -I/usr/share/R/include   -I"/home/rkrug/R/i486-pc-linux-gnu-library/2.13/Rcpp/include"   -fpic  -O3 -pipe  -g -c windDispCpp.cpp -o windDispCpp.o
: g++ -shared -o seedDisp.so windDispCpp.o -L/home/rkrug/R/i486-pc-linux-gnu-library/2.13/Rcpp/lib -lRcpp -Wl,-rpath,/home/rkrug/R/i486-pc-linux-gnu-library/2.13/Rcpp/lib -L/usr/lib/R/lib -lR


** build package

#+begin_src sh :results output
  R CMD build ./
#+end_src

#+results:



** load library

#+begin_src R :session :results output :var libname=(file-name-directory buffer-file-name)
## customize the next line as needed: 
.libPaths(new = file.path(getwd(),"Rlib") )
require( basename(libname), character.only=TRUE)
#+end_src

#+results:

- this loads the library into an R session
- customize or delete the =.libPaths= line as desired 


: #+begin_src R :session :var libname=(file-name-directory buffer-file-name)
: .libPaths(new = file.path(getwd(),"Rlib") )
: require( basename(libname), character.only=TRUE)
: #+end_src

** grep require( 

- if you keep all your source code in this =.org= document, then you do not
  need to do this - instead just type =C-s require(=
- list package dependencies that might need to be dealt with

#+begin_src sh :results output
grep 'require(' R/*
#+end_src

: #+begin_src sh :results output
: grep 'require(' R/*
: #+end_src

** set up .Rbuildignore and man, R, and Rlib directories

- This document sits in the top level source directory. So, ignore it
  and its offspring when checking, installing and building.
- List all files to ignore under =#+results: rbi=  (including this
  one!). Regular expressions are allowed.
- Rlib is optional. If you want to INSTALL in the system directory,
  you own't need it.

: #+results: rbi
#+results: rbi
: Rpackage.*
: PATCHVERSION
: MAJORVERSION
: MINORVERSION

Only need to run this once (unless you add more ignorable files).

#+begin_src R :results output silent :var rbld=rbi 
dir.create("./seedDisp")
cat(rbld,'\n', file="./.Rbuildignore")
dir.create("./man")
dir.create("./R")
dir.create("./src")
dir.create("./Rlib")
#+end_src

: #+begin_src R :results output silent :var rbld=rbi 
: cat(rbld,'\n', file=".Rbuildignore")
: dir.create("man")
: dir.create("R")
: dir.create("../Rlib")
: #+end_src

* Package structure and src languages                              :noexport:

- The top level directory may contain these files (and others):

| filename    | filetype      |
|-------------+---------------|
| INDEX       | text          |
| NAMESPACE   | R-like script |
| configure   | Bourne shell  |
| cleanup     | Bourne shell  |
| LICENSE     | text          |
| LICENCE     | text          |
| COPYING     | text          |
| NEWS        | text          |
| DESCRIPTION | [[http://www.debian.org/doc/debian-policy/ch-controlfields.html][DCF]]           |
|-------------+---------------|


 
   and subdirectories
| direname | types of files                                   |
|----------+--------------------------------------------------|
| R        | R                                                |
| data     | various                                          |
| demo     | R                                                |
| exec     | various                                          |
| inst     | various                                          |
| man      | Rd                                               |
| po       | poEdit                                           |
| src      | .c, .cc or .cpp, .f, .f90, .f95, .m, .mm, .M, .h |
| tests    | R, Rout                                          |
|----------+--------------------------------------------------|
|          |                                                  |
   
 [[info:emacs#Specifying%20File%20Variables][info:emacs#Specifying File Variables]]

* README.org
:PROPERTIES:
:tangle: README.org
:END:
#+begin_src org
,#+TITLE: seedDisp --- an R package to simulate seed dispersal
,#+DATE: <2013-09-03 Tue>
,#+AUTHOR: Rainer M. Krug
,#+EMAIL: Rainer@krugs.de
,#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
,#+OPTIONS: author:t c:nil creator:comment d:(not LOGBOOK) date:t e:t
,#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil stat:t tags:t
,#+OPTIONS: tasks:t tex:t timestamp:t toc:t todo:t |:t
,#+CREATOR: Emacs 24.3.1 (Org mode 8.0.7)
,#+DESCRIPTION:
,#+EXCLUDE_TAGS: noexport
,#+KEYWORDS:
,#+LANGUAGE: en
,#+SELECT_TAGS: export

The aim  of this package is to collect different seed dispersal routines usable in R to make finding and selecting seed dispersal function in R easier.


#+end_src
