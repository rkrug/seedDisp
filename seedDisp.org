# -*- org-babel-tangled-file: t; org-babel-tangle-run-postTangleScript: t; -*-

#+TITLE:     seedDisp.org
#+AUTHOR:    Rainer M Krug
#+EMAIL:     Rainer@krugs.de
#+DESCRIPTION: R Package Development Helpers
#+KEYWORDS: 

:CONFIG:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 

#+TODO: TODO OPTIMIZE TOGET COMPLETE WAIT VERIFY CHECK CODE DOCUMENTATION | DONE RECEIVED CANCELD 

#+STARTUP: indent hidestars nohideblocks
#+DRAWERS: HIDDEN PROPERTIES STATE CONFIG BABEL OUTPUT LATEXHEADER HTMLHEADER
#+STARTUP: nohidestars hideblocks
:END:
:HTMLHEADER:
#+begin_html
  <div id="subtitle" style="float: center; text-align: center;">
  <p>
Org-babel support for building 
  <a href="http://www.r-project.org/">R</a> packages
  </p>
  <p>
  <a href="http://www.r-project.org/">
  <img src="http://www.r-project.org/Rlogo.jpg"/>
  </a>
  </p>
  </div>
#+end_html
:END:
:LATEXHEADER:
#+LATEX_HEADER: \usepackage{rotfloat}
#+LATEX_HEADER: \definecolor{light-gray}{gray}{0.9}
#+LATEX_HEADER: \lstset{%
#+LATEX_HEADER:     basicstyle=\ttfamily\footnotesize,       % the font that is used for the code
#+LATEX_HEADER:     tabsize=4,                       % sets default tabsize to 4 spaces
#+LATEX_HEADER:     numbers=left,                    % where to put the line numbers
#+LATEX_HEADER:     numberstyle=\tiny,               % line number font size
#+LATEX_HEADER:     stepnumber=0,                    % step between two line numbers
#+LATEX_HEADER:     breaklines=true,                 %!! don't break long lines of code
#+LATEX_HEADER:     showtabs=false,                  % show tabs within strings adding particular underscores
#+LATEX_HEADER:     showspaces=false,                % show spaces adding particular underscores
#+LATEX_HEADER:     showstringspaces=false,          % underline spaces within strings
#+LATEX_HEADER:     keywordstyle=\color{blue},
#+LATEX_HEADER:     identifierstyle=\color{black},
#+LATEX_HEADER:     stringstyle=\color{green},
#+LATEX_HEADER:     commentstyle=\color{red},
#+LATEX_HEADER:     backgroundcolor=\color{light-gray},   % sets the background color
#+LATEX_HEADER:     columns=fullflexible,  
#+LATEX_HEADER:     basewidth={0.5em,0.4em}, 
#+LATEX_HEADER:     captionpos=b,                    % sets the caption position to `bottom'
#+LATEX_HEADER:     extendedchars=false              %!?? workaround for when the listed file is in UTF-8
#+LATEX_HEADER: }
:END:
:BABEL:
#+PROPERTY: exports code
#+PROPERTY: comments yes
#+PROPERTY: padline no
#+PROPERTY: var MAJORVERSION=0
#+PROPERTY: var+ MINORVERSION=4
#+PROPERTY: var+ PATCHVERSION=13
#+PROPERTY: var+ GITHASH="testhash" 
#+PROPERTY: var+ GITCOMMITDATE="testdate"
:END:

* Internal configurations                      :noexport:
** Evaluate to run post tangle script
#+begin_src emacs-lisp :results silent :tangle no :exports none
  (add-hook 'org-babel-post-tangle-hook
            (
             lambda () 
                    (call-process-shell-command "./postTangleScript.sh" nil 0 nil)
  ;;              (async-shell-command "./postTangleScript.sh")
  ;;              (ess-load-file (save-window-excursion (replace-regexp-in-string ".org" ".R" buffer-file-name)))))
  ;;              (ess-load-file "nsa.R")))
  ;;              (ess-load-file "spreadSim.R")
                    )
            )
#+end_src

** Post tangle script
:PROPERTIES:
:tangle: postTangleScript.sh
:END:
#+begin_src sh :tangle postTangleScript.sh
  sed -i '' s/MAJORVERSION/$MAJORVERSION/ ./DESCRIPTION
  sed -i '' s/MINORVERSION/$MINORVERSION/ ./DESCRIPTION
  sed -i '' s/PATCHVERSION/$PATCHVERSION/ ./DESCRIPTION
  sed -i '' s/TODAYSDATE/`date +%Y-%m-%d_%H-%M`/ ./DESCRIPTION

  sed -i '' s/MAJORVERSION/$MAJORVERSION/ ./seedDisp-package.R
  sed -i '' s/MINORVERSION/$MINORVERSION/ ./seedDisp-package.R
  sed -i '' s/PATCHVERSION/$PATCHVERSION/ ./seedDisp-package.R
  sed -i '' s/TODAYSDATE/`date +%Y-%m-%d_%H-%M`/ ./seedDisp-package.R

  Rscript -e "library(roxygen2);roxygenize('pkg', roxygen.dir='pkg', copy.package=FALSE, unlink.target=FALSE)"
  # rm -f ./postTangleScript.sh
#+end_src

#+RESULTS:


* gitignore file (./.gitignore)
:PROPERTIES:
:tangle: ./.gitignore
:comments: no
:no-expand: TRUE
:shebang:
:padline: no
:END: 
#+begin_src gitignore
  .#*
  #*
  *#
  *~
  *#seedDisp.*
  seedDisp.*
  !seedDisp.org*
  *.o
  *.so
  *.rds
#+end_src

* Git Revision info
Complete version info
#+begin_src sh :exports results :results output replace 
  echo "Version     : " $MAJORVERSION.$MINORVERSION-$PATCHVERSION
  echo "Commit date : " `git show -s --format="%ci" HEAD`
  echo "git HASH    : " `git rev-parse HEAD`
  echo "git status  : "
  git status
#+end_src

#+RESULTS:
: Version     :  .4-13
: Commit date :  2013-03-20 18:33:21 +0100
: git HASH    :  906d085c35b4b835082e4583c4134c5ddf7f1555
: git status  : 
: # On branch master
: nothing to commit, working directory clean



* Rbuildignore file (./.Rbuildignore)
:PROPERTIES:
:tangle: ./.Rbuildignore
:comments: no
:no-expand: TRUE
:shebang:
:padline: no
:END: 
#+begin_src fundamental
  .git
  ^.*\\.org$
  ^seedDisp.
  .gitignore
  library
  version
  postTangleScript.sh
#+end_src



* Package description
#+begin_src R :eval nil :tangle ./seedDisp-package.R :shebang :padline no :no-expand :comments no
  ##' Disperses seeds by using different routines
  ##' 
  ##' \tabular{ll}{
  ##' Package: \tab seedDisp\cr
  ##' Type: \tab Package\cr
  ##' Version: \tab MAJORVERSION.MINORVERSION.PATCHVERSION\cr
  ##' Date: \tab TODAYSDATE\cr
  ##' License: \tab GPL (>= 2)\cr
  ##' LazyLoad: \tab yes\cr
  ##' }
  ##'
  ##' @docType package
  ##' @author Rainer M Krug \email{Rainer@@krugs.de}
  NULL
#+end_src

* Package Files
** DESCRIPTION
:PROPERTIES:
:tangle:   ./DESCRIPTION
:padline: no 
:no-expand: TRUE
:comments: no
:END:
#+begin_src fundamental
Package: seedDisp
Type: Package
Title: Dispersal of seed routines
Version: MAJORVERSION.MINORVERSION-PATCHVERSION
Date: TODAYSDATE
Author: Rainer M. Krug
Maintainer: Rainer M Krug <Rainer@krugs.de>
Description: Collection of different seed dispersal routines.
License: GPL-3
LazyLoad: yes
Depends: Rcpp (>= 0.9.4), spgrass6
LinkingTo: Rcpp  
#+end_src

** NAMESPACE
:PROPERTIES:
:tangle:   ./NAMESPACE
:padline: no 
:no-expand: TRUE
:comments: no
:END:
#+begin_src R
  useDynLib(seedDisp)
  exportPattern("^[[:alpha:]]+")
#+end_src

#+results:


* R directory (./R)
** Wind dispersal
*** windDisp
#+begin_src R :eval nil :tangle ./R/windDisp.R :no-expand
  ##' Disperses seeds from a seed \code{matrix} by using a
  ##' 2 dimensional dispersal \code{matrix}
  ##'
  ##' A \code{matrix} of the same size as SEEDS containing the dispersed seeds 
  ##' @usage windDisp(SD2D, SEEDS, MASK)
  ##' @name windDisp
  ##' @title Dispersal of seeds by wind
  ##' @param SD2D \code{matrix} defining the 2D seed dispersal kernel 
  ##' @param SEEDS \code{matrix} specifying the number of seeds to be dispersed
  ##' @param MASK \code{matrix} defining the area in which processing takes place (\code{!is.na(MASK)}) 
  ##' @param zeroToNULL \code{boolean} if TRUE convert zeros to NA, otherwise NA to 0
  ##' @return \code{matrix} of same size as SEEDS containing the dispersed seeds
  ##' @author Rainer M Krug \email{Rainer@@krugs.de}
  ##' @export 
  ##' @callGraphPrimitives
  ##' @useDynLib seedDisp
  windDisp <- function(SD2D, SEEDS, MASK, zeroToNULL) {
    ## Calculate size parameter of sd2D
    dx2 <- (ncol(SD2D) - 1)
    dy2 <- (nrow(SD2D) - 1)
    dx <- dx2 / 2
    dy <- dy2 / 2
    ## buffer for dispersal into cells at the edge
    buffer <- matrix(NA, nrow=nrow(SEEDS), ncol=dx)
    SEEDS <- cbind(buffer, SEEDS, buffer)
    buffer <- matrix(NA, ncol=ncol(SEEDS), nrow=dy)
    SEEDS <- rbind(buffer, SEEDS, buffer)
    ## call C++ function
    output <- .Call(
                 "windDispCpp",
                 dx2,
                 dy2,
                 SD2D,
                 SEEDS,
                 MASK,
                 PACKAGE = "seedDisp"
                 )
    if (zeroToNULL) {
      output[output==0] <- NA
    } else {
      output[is.na(output)] <- 0
    }
    return(output)
  }
  
#+end_src

*** windDispGRASS
#+begin_src R :eval nil :tangle ./R/windDispGRASS.R :no-expand
  ##' Disperses seeds from a seed \code{matrix} by using a
  ##' 2 dimensional dispersal \code{matrix}
  ##' and doing the calculations based on raster in GRASS
  ##'
  ##' @usage windDisp(SD2D, input, output="windDispSeeds", overwrite=FALSE)
  ##' @name windDispGRASS
  ##' @title Dispersal of seeds by wind
  ##' @param SD2D \code{matrix} defining the 2D seed dispersal kernel 
  ##' @param input \code{character} name of GRASS raster layer specifying number of seeds to be dispersed
  ##' @param output \code{character} name of GRASS raster layer generated, containing the dispersed seeds
  ##' @param zeroToNULL  \code{boolean} if TRUE convert zeros to NULL, otherwise NA to 0
  ##' @param overwrite \code{boolean} TRUE to overwrite existing output raster
  ##' @return \code{character} name of the output layer
  ##' @author Rainer M Krug \email{Rainer@@krugs.de}
  ##' @export 
  ##' @callGraphPrimitives
  windDispGRASS <- function(SD2D, input, output="windDispSeeds", zeroToNULL=TRUE, overwrite=FALSE) {
    if ( length( execGRASS("g.mlist", type="rast", pattern=output, intern=TRUE) ) & !overwrite ) {
      stop(paste("Layer", output, "exists! Please specify 'overwrite=TRUE' or use different output name!"))
    } 
    ##
    seeds <- readRAST6(
                       c(
                         input,
                         "MASK"
                         ),
                       NODATA=-1
                       )
    ## seeds.m <- sgdfToMatrix(seeds, 1)
    seeds.m <- matrix(
                    seeds[[1]],
                    nrow=gridparameters(seeds)$cells.dim[1],
                    ncol=gridparameters(seeds)$cells.dim[2])
    ## mask.m <- sgdfToMatrix(seeds, 2)
    mask.m <- matrix(
                     seeds[[2]],
                     nrow=gridparameters(seeds)$cells.dim[1],
                     ncol=gridparameters(seeds)$cells.dim[2])
  
    dispSeeds.m <- windDisp(
                            SD2D = SD2D,
                            SEEDS = seeds.m,
                            MASK = mask.m,
                            zeroToNULL = zeroToNULL
                            )
  
    seeds@data[[2]] <- as.vector(dispSeeds.m)
    
    mode(seeds[[2]]) <- "double"
    ## seeds@proj4string <- parameter$proj4string
    writeRAST6(
               seeds,
               output,
               NODATA = -1,
               zcol=2,
               overwrite = overwrite
               )
    return(output)
  }
  
#+end_src

** Local dispersal
*** localDispGRASS
#+begin_src R  :eval nil :tangle ./R/localDispGRASS.R :no-expand
  ##' Locally disperse seeds from a seed layer using GRASS
  ##' 
  ##' @usage localDispGRASS(input, output, overwrite)
  ##' @name localDispGRASS
  ##' @title Dispersal of seeds locally, i.e. in surounding cells (half, evenly distributed)
  ##' @param input \code{character} name of GRASS raster layer specifying number of seeds to be dispersed
  ##' @param output \code{character} name of GRASS raster layer generated, containing the dispersed seeds
  ##' @param zeroToNULL \code{boolean} if TRUE convert zeros to NULL, otherwise NA to 0
  ##' @param overwrite \code{boolean} TRUE to overwrite existing output raster
  ##' @return \code{character} name of the output layer
  ##' @author Rainer M Krug \email{Rainer@@krugs.de}
  ##' @export 
  ##' @callGraphPrimitives
  localDispGRASS <- function(input, output="localDispSeeds", zeroToNULL=TRUE, overwrite=FALSE) {
      if ( length( execGRASS("g.mlist", type="rast", pattern=output, intern=TRUE) )  & !overwrite ) {
          stop(paste("Layer", output, "exists! Please specify 'overwrite=TRUE' or use different output name!"))
      } 
      r.mapcalc <- function(...)
          {
              comm <- paste( "r.mapcalc ", " \"", ..., "\" ", sep="" )
              system( comm, intern=TRUE )
          }
      ## temporary layer name
      tmp <- "TMP"
      ## calculate 16th of to be dispersed seeds and set nulls to 0
      r.mapcalc(
          tmp,
          " = ",
          "double( ", input, " / 16 )"
          ## 8/16 will remain in source cell,
          ## 8/16 will be evenly distributed in neighbouring cells
          )
      execGRASS(
          "r.null",
          map  = tmp,
          null = 0
          )
      ## Local Dispersal of all seeds in input
      r.mapcalc(
          output,
          " = ",
          "double( round(", 
          tmp, "[-1,-1] + ",
          tmp, "[-1, 0] + ",
          tmp, "[-1, 1] + ",
          tmp, "[ 0,-1] + ",
          " 8 * ", tmp, "[ 0, 0] + ",
          tmp, "[ 0, 1] + ",
          tmp, "[ 1,-1] + ",
          tmp, "[ 1, 0] + ",
          tmp, "[ 1, 1]",
          " ) )"
          )
      ## remove tmp
      execGRASS(
          cmd = "g.remove",
          rast = tmp
          )
      ## if zeroToNULL
      if (zeroToNULL) {
          execGRASS(
              "r.null",
              map=output,
              setnull="0",
              ignore.stderr=!options("asmDebug")[[1]]
              )
      } else {
          execGRASS(
              "r.null",
              map=output,
              null=0,
              ignore.stderr=!options("asmDebug")[[1]]
              )    
      }
      ## return name of output layer
      return(output)
  } 
  
#+end_src

** Bird dispersal
*** birdDispGRASS
#+begin_src R  :eval nil :tangle ./R/birdDispGRASS.R :no-expand
  ##' Bird disperse seeds from a seed layer using GRASS
  ##' 
  ##' @usage birdDispGRASS(input, output, overwrite)
  ##' @name birdDispGRASS
  ##' @title Dispersal of seeds by birds
  ##' 
  ##' @param input \code{character} name of GRASS raster layer specifying number of seeds to be dispersed
  ##' @param output \code{character} name of GRASS raster layer generated, containing the dispersed seeds
  ##' @param zeroToNULL \code{boolean} if TRUE convert zeros to NULL, otherwise NA to 0
  ##' @param overwrite \code{boolean} TRUE to overwrite existing output raster
  ##' @return \code{character} name of the output layer
  ##' @author Rainer M Krug \email{Rainer@@krugs.de}
  ##' @export 
  ##' @callGraphPrimitives
  birdDispGRASS <- function(input, output="birdDispSeeds", zeroToNULL=TRUE, overwrite=FALSE) {
    if ( length( execGRASS("g.mlist", type="rast", pattern=output, intern=TRUE) )  & !overwrite ) {
      stop(paste("Layer", output, "exists! Please specify 'overwrite=TRUE' or use different output name!"))
    } 
    MASK <- "MASK"
    seeds <- readRAST6(
                       c(
                         input,
                         MASK
                         ),
                       NODATA=-1
                       )
    oldWarn <- options()$warn
    options(warn=-1)
    seeds[[3]] <- 0
    seeds[[3]][!is.na(seeds[[MASK]])] <- rbinom(                                     # Bird dispersal
                                                cells <- sum(!is.na(seeds[[MASK]])), # into all cells which are not NULL in the region
                                                sum(seeds[[input]], na.rm=TRUE),     # seeds to disperse
                                                1/cells                              # probability is the same for each cell
                                                )
    options(warn=oldWarn)
  
    if (zeroToNULL) {
      seeds[[3]][seeds[[3]]==0] <- NA
    } else {
      seeds[[3]][is.na(seeds[[3]])] <- 0
    }
    writeRAST6(
               seeds,
               output,
               NODATA = -1,
               zcol=3,
               overwrite = overwrite
               )
    ## return name of output layer
    return(output)
  } 
  
#+end_src

** Water dispersal
*** waterDispGRASS
#+begin_src R  :eval nil :tangle ./R/waterDispGRASS.R :no-expand
##' Water disperse seeds from a seed layer using GRASS
##'
##' The principle in this module is as follow:
##' 1) calculate seeds which are deposited in cell and add these to the dispersedSeeds layer
##' 2) disperse in each direction separately to avoid overlap
##' 3) add up all dispersed seeds layers
##' 4) repeat until all seeds are in the deposit layer
##' 
##' @usage waterDispGRASS(input, output="waterDispSeeds", slope="SLOPE", flowdir="FLOWDIR", overwrite=FALSE)
##' @name waterDispGRASS
##' @title Dispersal of seeds by water
##' 
##' @param input \code{character} name of GRASS raster layer specifying number of seeds to be dispersed
##' @param output \code{character} name of GRASS raster layer generated, containing the dispersed seeds
##' @param flowdir \code{character} name of GRASS raster containing flow direction (in GRASS agnps format)
##' @param depRates \code{character} name of GRASS raster layer cotaining the dsposit rates for each cell.
##' @param overwrite \code{boolean} TRUE to overwrite existing output raster
##' @return \code{character} name of the output layer
##' @author Rainer M Krug \email{Rainer@@krugs.de}
##' @export 
##' @callGraphPrimitives
waterDispGRASS <- function(
    input,
    output,
    flowdir,
    depRates, 
    overwrite  = FALSE
    ) {
    if ( length( execGRASS("g.mlist", type="rast", pattern=output, intern=TRUE) )  & !overwrite ) {
        stop(paste("Layer", output, "exists! Please specify 'overwrite=TRUE' or use different output name!"))
    } 

    ## does one dispersal step and returns
    ## TRUE if executed
    ## FALSE if sum of stepInput is 0, i.e. no seeds to disperse
    oneStep <- function(stepInput, stepDep, stepToDisp, stepFlowdir, stepDepRates) {
        ## calculation of sum of seeds left to be dispersed
        univ <- execGRASS("r.univar", map=stepInput, intern=TRUE)
        sm <- grep("sum", univ, value=TRUE)
        s <- as.numeric(strsplit( sm, split=": " )[[1]][2])
        if ( s <= 0 ) {
            return(FALSE)
        } else {
            ## Calculate seeds to be deposited in cell and set null values to 0
            execGRASS(
                "r.mapcalc",
                expression = paste0(
                    stepDep,
                    " = ",
                    "round(", stepInput, " * ", stepDepRates, ", 1)"
                    )
                )
            execGRASS(
                "r.null",
                map = stepDep,
                null = 0L
                )
            ##
            
            ## Calculate seeds to be dispersed and set null values to 0
            execGRASS(
                "r.mapcalc",
                expression = paste0(
                    "_tmp.wd.disp = ",
                    "max( ", stepInput, " - ", stepDep, ", 0 )"
                    )
                )
            execGRASS(
                "r.null",
                map = "_tmp.wd.disp",
                null = 0L
                )

            ## combine expressions for r.mapcalc
            mce <- paste0(
                "_tmp.wd.into.", 1:8,
                " = ",
                "if( ", stepFlowdir, "[",
                c(1,  1,  0, -1, -1, -1,  0,  1),
                ", ",
                c(0, -1, -1, -1,  0,  1,  1,  1),
                " ] == ", 1:8,
                ", _tmp.wd.disp[ ",
                c(1,  1,  0, -1, -1, -1,  0,  1),
                ", ",
                c(0, -1, -1, -1,  0,  1,  1,  1),
                " ], null() )"
                ) 

            ## calculate all and set null vaues to 0 
            for (i in 1:length(mce)) {
                execGRASS(
                    "r.mapcalc",
                    expression = mce[i]
                    )
                execGRASS(
                    "r.null",
                    map = paste0("_tmp.wd.into.", i),
                    null = 0L
                    )
            }

            ## and finally sum them up
            execGRASS(
                "r.mapcalc",
                expression = paste0(
                    stepToDisp,
                    " = ",
                    paste0("_tmp.wd.into.", c(1:8), collapse = " + ")
                    ),
                flags = "overwrite"
                )
            
            ## and finally delete all temporary layers
            execGRASS(
                "g.mremove",
                rast = "_tmp.wd.*",
                flags = "f"
                )
            return(TRUE)
        }
    }

    ## copy input in temporary input layer
    execGRASS(
        "g.copy",
        rast = paste0(input, ",_tmp.wdout.input")
        )
    ## create empty deposit layer
    execGRASS(
        "r.mapcalc",
        expression = "_tmp.wdout.dep.final = 0"
        )
    while (oneStep("_tmp.wdout.input", "_tmp.wdout.dep", "_tmp.wdout.disp", flowdir, depRates)) {
        univ <- execGRASS("r.univar", map="_tmp.wdout.input", intern=TRUE)
        sm <- grep("sum", univ, value=TRUE)
        paste("############", as.numeric(strsplit( sm, split=": " )[[1]][2]), "############")
        ## copy still to be dispersed seeds into temporary input layer
        execGRASS(
            "g.copy",
            rast = "_tmp.wdout.disp,_tmp.wdout.input",
            flags = "overwrite"
            )
        ## add the deposited seeds to the final deposit layer
        execGRASS(
            "r.mapcalc",
            expression = "_tmp.wdout.dep.final = _tmp.wdout.dep.final + _tmp.wdout.dep",
            flags = "overwrite"
            )
        ## remove _tmp.wdout.dep
        execGRASS(
            "g.remove",
            rast = "_tmp.wdout.dep",
            flags = "f"
            )
        ## and continue, i.e. execute oneStep() and repeat until oneStep returns FALSE
        ## Then nothing needs to be done anymore
    }  
   
    ## set 0 values to null and write temporary layer to output layer
    execGRASS(
        "r.null",
        map = "_tmp.wdout.dep.final",
        setnull = "0"
        )
    if (overwrite) {
        fl <- "overwrite"
    } else {
        fl <- NULL
    }
    execGRASS(
        "g.copy",
        rast = paste0("_tmp.wdout.dep.final", ",", output),
        flags = fl
        )
    ## and delete temporary layers
    execGRASS(
        "g.mremove",
        rast = "_tmp.wdout.*",
        flags = "f"
        )
    invisible(output)
}

#+end_src

* src directory (./src)
:PROPERTIES:
:no-expand: true
:END:
** Makevars
#+begin_src sh :results silent :tangle ./src/Makevars :eval nil
  ## Use the R_HOME indirection to support installations of multiple R version
  PKG_LIBS = `$(R_HOME)/bin/Rscript -e "Rcpp:::LdFlags()"`
  
  ## As an alternative, one can also add this code in a file 'configure'
  ##
  ##    PKG_LIBS=`${R_HOME}/bin/Rscript -e "Rcpp:::LdFlags()"`
  ## 
  ##    sed -e "s|@PKG_LIBS@|${PKG_LIBS}|" \
  ##        src/Makevars.in > src/Makevars
  ## 
  ## which together with the following file 'src/Makevars.in'
  ##
  ##    PKG_LIBS = @PKG_LIBS@
  ##
  ## can be used to create src/Makevars dynamically. This scheme is more
  ## powerful and can be expanded to also check for and link with other
  ## libraries.  It should be complemented by a file 'cleanup'
  ##
  ##    rm src/Makevars
  ##
  ## which removes the autogenerated file src/Makevars. 
  ##
  ## Of course, autoconf can also be used to write configure files. This is
  ## done by a number of packages, but recommended only for more advanced users
  ## comfortable with autoconf and its related tools.
  
  
#+end_src

** Makevars.win
#+begin_src sh :results silent :tangle ./src/Makevars.win :eval nil
  ## Use the R_HOME indirection to support installations of multiple R version
  PKG_LIBS = $(shell "${R_HOME}/bin${R_ARCH_BIN}/Rscript.exe" -e "Rcpp:::LdFlags()")
#+end_src
** windDispCpp.h
#+begin_src c++ :tangle ./src/windDispCpp.h
  #ifndef _test_WINDDISPCPP_H
  #define _test_WINDDISPCPP_H
  
  #include <Rcpp.h>
  
  /*
   * note : RcppExport is an alias to `extern "C"` defined by Rcpp.
   *
   * It gives C calling convention to the rcpp_hello_world function so that 
   * it can be called from .Call in R. Otherwise, the C++ compiler mangles the 
   * name of the function and .Call can't find it.
   *
   * It is only useful to use RcppExport when the function is intended to be called
   * by .Call. See the thread http://thread.gmane.org/gmane.comp.lang.r.rcpp/649/focus=672
   * on Rcpp-devel for a misuse of RcppExport
   */
  
  RcppExport SEXP windDispCpp( SEXP DX2, SEXP DY2, SEXP SD2D, SEXP SEEDS, SEXP MASK) ;
  
  // definition
  
  #endif
  
#+end_src

** windDispCpp.cpp
#+BEGIN_SRC c++ :tangle ./src/windDispCpp.cpp
  #include "windDispCpp.h"
  
  SEXP windDispCpp( SEXP DX2, SEXP DY2, SEXP SD2D, SEXP SEEDS, SEXP MASK ){
    using namespace Rcpp;
  
    // The input parameter  
    int dx2 = as<int>(DX2); // by reference or value?
    int dy2 = as<int>(DY2);
    NumericVector sd2D (SD2D); // by reference!
    IntegerMatrix seeds (SEEDS);
    IntegerMatrix mask (MASK);
  
    // result vector
    IntegerMatrix dispSeeds = clone<IntegerMatrix>(mask);
  
    // internal variables
    IntegerVector s (sd2D.size());
    RNGScope scope;                 // N.B. Needed when calling random number generators
  
    int res; 
    int nc = dispSeeds.ncol();
    int nr = dispSeeds.nrow();
    
    // BEGIN loop over seeds grid ("moving")
    for( int y=0; y < nc; y++ ){
      for( int x=0; x < nr; x++ ){
        // BEGIN loop over sd2D ("window")
        if ( dispSeeds(x, y) >= 0 ) {
          int indS = 0;
          for( int xS=x; xS <= x + dx2; xS++ )
            for( int yS=y; yS <= y + dy2; yS++, indS++ )
              s[indS]=seeds(xS, yS);
          res = 0;
          for( int i=0; i<s.size(); i++ ){
            if (s[i]>0 && sd2D[i]>0) {
              res += (int) ::Rf_rbinom((double)(s[i]), sd2D[i]);
            }
          }
          dispSeeds(x, y) = res;
        }
      }
    }
    // END loop over seeds
  
    return wrap( dispSeeds );
  }
#+END_SRC

* TODO Local tests
** seed disp
#+begin_src R 

#+end_src
* TODO Vignette
Write vignette
* package management                                               :noexport:
** check package
#+begin_src sh :results output
  CWD=`pwd`
  R CMD check pkg | sed 's/^*/ */'
#+end_src

#+results:
#+begin_example
 * using log directory ‘/home/rkrug/Documents/Projects/R-Packages/seeddisp/pkg.Rcheck’
 * using R version 2.13.2 (2011-09-30)
 * using platform: i686-pc-linux-gnu (32-bit)
 * using session charset: UTF-8
 * checking for file ‘DESCRIPTION’ ... OK
 * checking extension type ... Package
 * this is package ‘seedDisp’ version ‘0.0-13’
 * checking package namespace information ... OK
 * checking package dependencies ... OK
 * checking if this is a source package ... WARNING
Subdirectory ‘seedDisp/src’ contains object files.
 * checking for executable files ... OK
 * checking whether package ‘seedDisp’ can be installed ... OK
 * checking installed package size ... OK
 * checking package directory ... OK
 * checking for portable file names ... OK
 * checking for sufficient/correct file permissions ... OK
 * checking DESCRIPTION meta-information ... OK
 * checking top-level files ... OK
 * checking index information ... OK
 * checking package subdirectories ... WARNING
Subdirectory 'inst' contains no files.
 * checking R files for non-ASCII characters ... OK
 * checking R files for syntax errors ... OK
 * checking whether the package can be loaded ... OK
 * checking whether the package can be loaded with stated dependencies ... OK
 * checking whether the package can be unloaded cleanly ... OK
 * checking whether the namespace can be loaded with stated dependencies ... OK
 * checking whether the namespace can be unloaded cleanly ... OK
 * checking for unstated dependencies in R code ... OK
 * checking S3 generic/method consistency ... OK
 * checking replacement functions ... OK
 * checking foreign function calls ... OK
 * checking R code for possible problems ... OK
 * checking Rd files ... OK
 * checking Rd metadata ... OK
 * checking Rd cross-references ... OK
 * checking for missing documentation entries ... WARNING
Undocumented code objects:
  waterDisp
All user-level objects in a package should have documentation entries.
See the chapter 'Writing R documentation files' in the 'Writing R
Extensions' manual.
 * checking for code/documentation mismatches ... WARNING
Codoc mismatches from documentation object 'birdDispGRASS':
birdDispGRASS
  Code: function(input, output = "birdDispSeeds", zeroToNULL = TRUE,
                 overwrite = FALSE)
  Docs: function(input, output, overwrite)
  Argument names in code not in docs:
    zeroToNULL
  Mismatches in argument names:
    Position: 3 Code: zeroToNULL Docs: overwrite
  Mismatches in argument default values:
    Name: 'output' Code: "birdDispSeeds" Docs: 
    Name: 'overwrite' Code: FALSE Docs: 

Codoc mismatches from documentation object 'localDispGRASS':
localDispGRASS
  Code: function(input, output = "localDispSeeds", zeroToNULL = TRUE,
                 overwrite = FALSE)
  Docs: function(input, output, overwrite)
  Argument names in code not in docs:
    zeroToNULL
  Mismatches in argument names:
    Position: 3 Code: zeroToNULL Docs: overwrite
  Mismatches in argument default values:
    Name: 'output' Code: "localDispSeeds" Docs: 
    Name: 'overwrite' Code: FALSE Docs: 

Codoc mismatches from documentation object 'waterDispGRASS':
waterDispGRASS
  Code: function(input, output = "waterDispSeeds", slope = "slope",
                 flowdir = "flowdir", depRates, overwrite = FALSE,
                 zeroToNULL = TRUE, progress = TRUE)
  Docs: function(input, output = "waterDispSeeds", slope = "SLOPE",
                 flowdir = "FLOWDIR", overwrite = FALSE)
  Argument names in code not in docs:
    depRates zeroToNULL progress
  Mismatches in argument names:
    Position: 5 Code: depRates Docs: overwrite
  Mismatches in argument default values:
    Name: 'slope' Code: "slope" Docs: "SLOPE"
    Name: 'flowdir' Code: "flowdir" Docs: "FLOWDIR"

Codoc mismatches from documentation object 'windDisp':
windDisp
  Code: function(SD2D, SEEDS, MASK, zeroToNULL)
  Docs: function(SD2D, SEEDS, MASK)
  Argument names in code not in docs:
    zeroToNULL

Codoc mismatches from documentation object 'windDispGRASS':
windDisp
  Code: function(SD2D, SEEDS, MASK, zeroToNULL)
  Docs: function(SD2D, input, output = "windDispSeeds", overwrite =
                 FALSE)
  Argument names in code not in docs:
    SEEDS MASK zeroToNULL
  Argument names in docs not in code:
    input output overwrite
  Mismatches in argument names:
    Position: 2 Code: SEEDS Docs: input
    Position: 3 Code: MASK Docs: output
    Position: 4 Code: zeroToNULL Docs: overwrite

 * checking Rd \usage sections ... WARNING
Documented arguments not in \usage in documentation object 'waterDispGRASS':
  depRates

Objects in \usage without \alias in documentation object 'windDispGRASS':
  windDisp

Functions with \usage entries need to have the appropriate \alias
entries, and all their arguments documented.
The \usage entries must correspond to syntactically valid R code.
See the chapter 'Writing R documentation files' in the 'Writing R
Extensions' manual.
 * checking Rd contents ... OK
 * checking for unstated dependencies in examples ... OK
 * checking line endings in C/C++/Fortran sources/headers ... OK
 * checking line endings in Makefiles ... OK
 * checking for portable compilation flags in Makevars ... OK
 * checking for portable use of $(BLAS_LIBS) and $(LAPACK_LIBS) ... OK
 * checking examples ... NONE
 * checking PDF version of manual ... OK
WARNING: There were 5 warnings, see
  ‘/home/rkrug/Documents/Projects/R-Packages/seeddisp/pkg.Rcheck/00check.log’
for details
#+end_example



** INSTALL package

#+begin_src sh :results output :var rckopts="--library=./Rlib"
  R CMD INSTALL $rckopts pkg
#+end_src

#+results:
: g++ -I/usr/share/R/include   -I"/home/rkrug/R/i486-pc-linux-gnu-library/2.13/Rcpp/include"   -fpic  -O3 -pipe  -g -c windDispCpp.cpp -o windDispCpp.o
: g++ -shared -o seedDisp.so windDispCpp.o -L/home/rkrug/R/i486-pc-linux-gnu-library/2.13/Rcpp/lib -lRcpp -Wl,-rpath,/home/rkrug/R/i486-pc-linux-gnu-library/2.13/Rcpp/lib -L/usr/lib/R/lib -lR


** build package

#+begin_src sh :results output
  R CMD build ./
#+end_src

#+results:



** load library

#+begin_src R :session :results output :var libname=(file-name-directory buffer-file-name)
## customize the next line as needed: 
.libPaths(new = file.path(getwd(),"Rlib") )
require( basename(libname), character.only=TRUE)
#+end_src

#+results:

- this loads the library into an R session
- customize or delete the =.libPaths= line as desired 


: #+begin_src R :session :var libname=(file-name-directory buffer-file-name)
: .libPaths(new = file.path(getwd(),"Rlib") )
: require( basename(libname), character.only=TRUE)
: #+end_src

** grep require( 

- if you keep all your source code in this =.org= document, then you do not
  need to do this - instead just type =C-s require(=
- list package dependencies that might need to be dealt with

#+begin_src sh :results output
grep 'require(' R/*
#+end_src

: #+begin_src sh :results output
: grep 'require(' R/*
: #+end_src

** set up .Rbuildignore and man, R, and Rlib directories

- This document sits in the top level source directory. So, ignore it
  and its offspring when checking, installing and building.
- List all files to ignore under =#+results: rbi=  (including this
  one!). Regular expressions are allowed.
- Rlib is optional. If you want to INSTALL in the system directory,
  you own't need it.

: #+results: rbi
#+results: rbi
: Rpackage.*
: PATCHVERSION
: MAJORVERSION
: MINORVERSION

Only need to run this once (unless you add more ignorable files).

#+begin_src R :results output silent :var rbld=rbi 
dir.create("./seedDisp")
cat(rbld,'\n', file="./.Rbuildignore")
dir.create("./man")
dir.create("./R")
dir.create("./src")
dir.create("./Rlib")
#+end_src

: #+begin_src R :results output silent :var rbld=rbi 
: cat(rbld,'\n', file=".Rbuildignore")
: dir.create("man")
: dir.create("R")
: dir.create("../Rlib")
: #+end_src

* Package structure and src languages                              :noexport:

- The top level directory may contain these files (and others):

| filename    | filetype      |
|-------------+---------------|
| INDEX       | text          |
| NAMESPACE   | R-like script |
| configure   | Bourne shell  |
| cleanup     | Bourne shell  |
| LICENSE     | text          |
| LICENCE     | text          |
| COPYING     | text          |
| NEWS        | text          |
| DESCRIPTION | [[http://www.debian.org/doc/debian-policy/ch-controlfields.html][DCF]]           |
|-------------+---------------|


 
   and subdirectories
| direname | types of files                                   |
|----------+--------------------------------------------------|
| R        | R                                                |
| data     | various                                          |
| demo     | R                                                |
| exec     | various                                          |
| inst     | various                                          |
| man      | Rd                                               |
| po       | poEdit                                           |
| src      | .c, .cc or .cpp, .f, .f90, .f95, .m, .mm, .M, .h |
| tests    | R, Rout                                          |
|----------+--------------------------------------------------|
|          |                                                  |
   
 [[info:emacs#Specifying%20File%20Variables][info:emacs#Specifying File Variables]]
